<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Colin&#39;s Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-05T05:37:19.615Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Colinblack</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql</title>
    <link href="http://yoursite.com/2020/07/04/mysql/"/>
    <id>http://yoursite.com/2020/07/04/mysql/</id>
    <published>2020-07-04T14:10:21.000Z</published>
    <updated>2020-07-05T05:37:19.615Z</updated>
    
    <content type="html"><![CDATA[<h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li><p>新建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 名</span><br></pre></td></tr></table></figure></li><li><p>删除表  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLES 名</span><br></pre></td></tr></table></figure></li><li><p>插入　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表 VALUES()</span><br><span class="line">eg: insert into user(name) values(&quot;cale&quot;)</span><br></pre></td></tr></table></figure></li><li><p>sql导出数据库  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">＃只导整个库结构:</span><br><span class="line">    mysqldump -uroot -p1234 -d sg17_s0 &gt; sg17_s0.sql</span><br><span class="line">＃导出整个库结构和数据:</span><br><span class="line">    mysqldump -uroot -p1234 sg17_s0 &gt; sg17_s0.sql</span><br><span class="line">＃只导出表结构:</span><br><span class="line">    mysqldump -uroot -p1234 -d sg17_s0 concern &gt; concern.sql</span><br></pre></td></tr></table></figure></li><li><p>sql导入数据库　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source [所在的路径&#x2F;&#x2F;*.sql]</span><br><span class="line">mysql -uabc_f -p abc &lt; abc.sql</span><br></pre></td></tr></table></figure></li><li><p>查看端口 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &#39;port&#39;</span><br></pre></td></tr></table></figure></li><li><p>insert into 和 replace into 比较  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据存在时, replace 为替换</span><br><span class="line">数据不存在时，replace 为插入且效率比insert高</span><br></pre></td></tr></table></figure></li><li><p>显示建表语句  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table mainline_task_stat_zkw</span><br></pre></td></tr></table></figure></li><li><p>删除带主键约束的行<br><img src="/images/mysql_20200705_1.png" alt="p1"></p></li></ul><ul><li><p>删除主键约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table stat_online_players drop primary key; #增加主键约束（要先删掉数据吗?)</span><br><span class="line">alter table stat_online_players add primary key(zone_id, date);#主键要先删再加才行</span><br></pre></td></tr></table></figure></li><li><p>增加新行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table stat_online_players add time char(12);</span><br></pre></td></tr></table></figure></li><li><p>删除行　　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table stat_online_players drop column hour, drop column minute;　＃如果有主键约束必须先删掉主键约束</span><br></pre></td></tr></table></figure></li><li><p>修改字段  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table base modify column recover_time int(10) NOT NULL DEFAULT &#39;0&#39;;</span><br></pre></td></tr></table></figure></li><li><p>调换行的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table stat_online_players modify player int(10) unsigned after time;</span><br></pre></td></tr></table></figure></li><li><p>修改数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update base set assist_end_ts&#x3D;0 where uid&#x3D;10001348;</span><br></pre></td></tr></table></figure></li><li><p>修改字段名 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table base change barrier archive_chip binary(24) NOT NULL DEFAULT &#39;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&#39;;</span><br></pre></td></tr></table></figure></li><li><p>求和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sum(peoples) as total from tutorial_stage_stat where day_id&#x3D;19;</span><br></pre></td></tr></table></figure></li><li><p>修改表结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table stat_key_data_online modify &#96;date&#96; char(12) NOT NULL</span><br></pre></td></tr></table></figure></li><li><p>按列显示  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from T_Account limit 1\G</span><br></pre></td></tr></table></figure></li><li><p>pymysql </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装(centos 6)：</span><br><span class="line">安装pip: sudo yum -y install epel-release, sudo yum -y install python-pip</span><br><span class="line">安装mypython: yum install -y mysql-devel, python-devel python-setuptools</span><br><span class="line">             pip install MySQL-python</span><br><span class="line">安装mysql.connector包 pip install mysql-connector</span><br></pre></td></tr></table></figure></li><li><p>查看mysql 配置文件的方法  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which mysqld</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin&#x2F;mysql --verbose --help | grep -A 1 &#39;Default options&#39;</span><br></pre></td></tr></table></figure></li><li><p>MySQL中文乱码<br><a href="https://mp.weixin.qq.com/s?__biz=MzIzNjg4MTE2Ng==&idx=4&mid=100000774&sn=c4ed7a8c2fee681523c3e30600be4bf8" target="_blank" rel="noopener">彻底解决MySQL中文乱码</a></p></li><li><p>mysql修改数据库表和表中的字段的编码格式的修改<br><a href="https://blog.csdn.net/luo4105/article/details/50804148" target="_blank" rel="noopener">mysql修改数据库表和表中的字段的编码格式的修改</a></p></li><li><p>mysql的latin1支持中文<br><a href="https://blog.csdn.net/congcongsuiyue/article/details/41979643" target="_blank" rel="noopener">mysql的latin1支持中文</a></p></li><li><p>mysql 两表联合查询<br><a href="https://blog.csdn.net/wj123446/article/details/52870114/" target="_blank" rel="noopener">mysql两表联合查询的四种情况</a></p></li><li><p>mysql 设置最大连接数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.第一种：命令行查看和修改最大连接数(max_connections)。</span><br><span class="line">  &gt;mysql -uuser -ppassword(命令行登录MySQL)</span><br><span class="line">  mysql&gt;show variables like &#39;max_connections&#39;;(查可以看当前的最大连接数)</span><br><span class="line">  msyql&gt;set global max_connections&#x3D;1000;(设置最大连接数为1000，可以再次查看是否设置成功)</span><br><span class="line">  mysql&gt;exit  </span><br><span class="line">2.设置&#x2F;etc&#x2F;my.cnf</span><br><span class="line">  注:似乎两者都要设置才会成功</span><br></pre></td></tr></table></figure></li><li><p>查看错误日志路径  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在配置中查看</span><br><span class="line">&#x2F;data&#x2F;mysql&#x2F;var</span><br><span class="line">数据库存放路径</span><br><span class="line">&#x2F;var&#x2F;log&#x2F;message</span><br><span class="line">系统日志</span><br></pre></td></tr></table></figure></li><li><p>数据库遭到攻击<br><a href="https://jason5.cn/blog/ji-%5B%3F%5D-ci-shu-ju-ku-bei-gong-ji-de-jing-li.html" target="_blank" rel="noopener">数据库遭到攻击</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;命令&quot;&gt;&lt;a href=&quot;#命令&quot; class=&quot;headerlink&quot; title=&quot;命令&quot;&gt;&lt;/a&gt;命令&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新建数据库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>makefile</title>
    <link href="http://yoursite.com/2020/07/04/makefile/"/>
    <id>http://yoursite.com/2020/07/04/makefile/</id>
    <published>2020-07-04T13:40:24.000Z</published>
    <updated>2020-07-04T14:01:00.182Z</updated>
    
    <content type="html"><![CDATA[<ul><li>makefile中赋值号<br>=  直接赋值<br>:= 把之前的值替换掉<br>?= 如果变量中没值则赋值，有值则不赋值   </li></ul><p>+= 在变量未追加   </p><ul><li>makefile中的shell<br>作用域<br>目标项冒号后另起一行才是shell代码<br>$(shell  这里是shell代码)    <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> get_trunk_path  </span><br><span class="line">    trunk_path=`pwd`; \ </span><br><span class="line">    for dir in <span class="variable">$(dirs)</span>; do \ </span><br><span class="line">      if [[ $$&#123;trunk_path&#125; = *$$dir* ]]; then \ </span><br><span class="line">        trunk_path=`echo $$&#123;trunk_path&#125; | sed <span class="string">"s/\/$$dir.*//"</span>`; \</span><br><span class="line">        break; \    </span><br><span class="line">      fi \    </span><br><span class="line">    done; \</span><br><span class="line">    echo $$&#123;trunk_path&#125;</span><br><span class="line"><span class="keyword">endef</span>  </span><br><span class="line"></span><br><span class="line">PATH_PLATFORM_PRJ := <span class="variable">$(<span class="built_in">shell</span> $(<span class="built_in">call</span> get_trunk_path)</span>)</span><br></pre></td></tr></table></figure>makefile中的shell，每一行是一个进程，不同行之间变量值不能传递。所以，Makefile中的shell不管多长也要写在一行，每行后面加;\ 如上例  </li></ul><p>makefile定义的变量使用${var}, shell定义的变量使用$${var}  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//运行方式，直接make</span><br><span class="line">PATH=<span class="string">"data"</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">   echo &#123;PATH&#125;</span><br><span class="line">   PATH=<span class="string">"555"</span>;\</span><br><span class="line">   echo $&#123;PATH&#125;;\ //data</span><br><span class="line">   echo $$&#123;PATH&#125; //555</span><br></pre></td></tr></table></figure><p>makefile中赋值可以这样写var = 123, shell中不能留空格var=123  </p><ul><li>makefile中的模式规则  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">%:%.cpp  #冒号左边表示所有的target, 右边表示依赖的cpp文件           </span></span><br><span class="line">  g++ <span class="variable">$&lt;</span> -o <span class="variable">$@</span>   <span class="comment">#"$&lt;"表示了所有依赖目标的挨个值, "$@"表示所有的目标的挨个值</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;makefile中赋值号&lt;br&gt;=  直接赋值&lt;br&gt;:= 把之前的值替换掉&lt;br&gt;?= 如果变量中没值则赋值，有值则不赋值   &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;+= 在变量未追加   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;makefile中的shell&lt;br&gt;作用域&lt;br
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>shell</title>
    <link href="http://yoursite.com/2020/07/04/shell/"/>
    <id>http://yoursite.com/2020/07/04/shell/</id>
    <published>2020-07-04T11:10:37.000Z</published>
    <updated>2020-07-04T13:34:07.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash                                                                    </span></span><br><span class="line">                                                                               </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ];<span class="keyword">then</span>                                                            </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"arg count must &gt; 1"</span>                                                    </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Uage bash -x example_1.sh [args...]"</span>                                  </span><br><span class="line">   <span class="built_in">exit</span>                                                                        </span><br><span class="line"><span class="keyword">fi</span>                                                                              </span><br><span class="line">                                                                               </span><br><span class="line">arg=<span class="variable">$1</span>                                                                          </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$arg</span> -gt 10 ];<span class="keyword">then</span>                                                          </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$arg</span> &gt; 10"</span>                                                            </span><br><span class="line"><span class="keyword">else</span>                                                                            </span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"<span class="variable">$arg</span> &lt;= 10"</span>                                                            </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><ul><li><p>if [[…]] 表示模式匹配   </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="variable">$trunk_path</span> = *<span class="variable">$dir</span>* ]]; <span class="keyword">then</span>                     </span><br><span class="line">    trunk_path=`<span class="built_in">echo</span> $<span class="variable">$&#123;trunk_path&#125;</span> | sed <span class="string">"s/\/$<span class="variable">$dir</span>.*//"</span>`  </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li><li><p>数组，函数传参数，for循环</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"args must &gt; 1"</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"Usage bash +x example_2.sh [args...]"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args=<span class="variable">$@</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="variable">$args</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">func1</span></span>()&#123;</span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$1</span> <span class="comment">#$1是该函数的第一个参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func1 <span class="string">"hello everybody"</span> <span class="comment">#函数传参</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种写法</span></span><br><span class="line"><span class="function"><span class="title">func2</span></span>()&#123;</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"bash shell function defination"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func2 <span class="comment">#调用</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line">array=(<span class="string">"hello"</span>  <span class="string">"gg"</span> 1 <span class="string">"shit"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"first element is <span class="variable">$&#123;array[0]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"second element is <span class="variable">$&#123;array[1]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"third element is <span class="variable">$&#123;array[2]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fourth element is <span class="variable">$&#123;array[3]&#125;</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"all element are <span class="variable">$&#123;array[@]&#125;</span>"</span> <span class="comment">#所有的元素</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"size of array is <span class="variable">$&#123;#array[@]&#125;</span>"</span> <span class="comment">#数组的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="variable">$&#123;array[@]&#125;</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$arg</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><ul><li><p>While循环以及其它几种循环、case、表达式expr  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"args must &gt; 1"</span></span><br><span class="line">           <span class="built_in">echo</span> <span class="string">"Usage bash +x example_2.sh [args...]"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">   <span class="string">"install"</span>)</span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"operation is install"</span></span><br><span class="line">   ;;</span><br><span class="line">   </span><br><span class="line">   <span class="string">"uninstall"</span>)</span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"operation is uninstall"</span></span><br><span class="line">   ;;</span><br><span class="line">   *)</span><br><span class="line">       <span class="built_in">echo</span> <span class="string">"operation is not support"</span></span><br><span class="line">   ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ((i=0; i&lt;10; i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="keyword">if</span> ((i==1));<span class="keyword">then</span></span><br><span class="line">       <span class="built_in">continue</span></span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'seq 5'</span>; <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"loop <span class="variable">$i</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li><li><p>脚本之间的引用<br>/lib/lsb/init-functions  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">first.sh</span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"execute first script"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file=first</span><br><span class="line"></span><br><span class="line">second.sh</span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">. first.sh  <span class="comment">##引用脚本</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$file</span></span><br></pre></td></tr></table></figure></li><li><p>错误处理<br>$?<br>set -o errexit  //遇到报错不会往下执行<br>command &gt; file 2&gt;&amp;1 //将stdout和stderr合并后重定向到文件  </p></li><li><p>字典</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -o errexit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#方式1</span></span><br><span class="line"><span class="function"><span class="title">hput</span></span>()&#123;</span><br><span class="line">   <span class="built_in">eval</span> <span class="string">"hkey_<span class="variable">$1</span>"</span>=<span class="string">"<span class="variable">$2</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">hget</span></span>()&#123;</span><br><span class="line">   <span class="built_in">eval</span> <span class="built_in">echo</span> <span class="string">'$&#123;'</span><span class="string">"hkey_<span class="variable">$1</span>"</span><span class="string">'&#125;'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hput k1 value1</span><br><span class="line">hget k1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#方式2</span></span><br><span class="line"><span class="built_in">declare</span> -A dic</span><br><span class="line">dic=([key1]=<span class="string">"value1"</span> [key2]=<span class="string">"value2"</span> [key3]=<span class="string">"value3"</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dic["key1"]&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!dic[@]&#125;</span> <span class="comment">#打印所有的key</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;dic[@]&#125;</span> <span class="comment">#打印所有的值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> <span class="variable">$&#123;!dic[@]&#125;</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">   <span class="built_in">echo</span> <span class="variable">$key</span>: <span class="variable">$&#123;dic[$key]&#125;</span><span class="string">""</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><ul><li>trap<br>shell脚本执行时产生三个伪信号，可使用trap捕获 ，并输出调试信息   <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">信号名              产生原因</span><br><span class="line">EXIT               从一个函数中退出或整个脚本执行完毕</span><br><span class="line">ERR                从一条命令返回非零状态时（代表命令执行不成功） </span><br><span class="line">DEBUG              脚本中每一条命令执行之前</span><br></pre></td></tr></table></figure></li><li>tee　　</li><li>调试钩子　</li><li>shell参数<br>man sh 查看  </li></ul><p>-n 只读取， 不执行， 例如 sh -n *.sh  好像只能检查语法是否有问题<br>-x 进入跟踪方式，打印执行的每一条指令<br>输出的默认值$PS4是”+”，可以设置环境变量export PS4=’+{$LINENO:${FUNCNAME[0]}}’;  echo $PS4 </p><h3 id="命令"><a href="#命令" class="headerlink" title="命令　 　"></a>命令　 　</h3><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls file | xargs rm  //查看文件并删除</span><br><span class="line">ls -l  *.cpp *.c *.h | awk <span class="string">'&#123;sum+=$5&#125; END &#123;print sum&#125;'</span> // 统计文件大小总和</span><br><span class="line">ls -lt //按时间排列，时间又近及远</span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp s1/conf/ActivityTime.json ./s[2-3]/conf/ -r  //递归拷贝文件</span><br></pre></td></tr></table></figure><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux --sort=lstart    //进程按时间排序</span><br></pre></td></tr></table></figure><h4 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -p | wcl -c  //查看系统线程数</span><br></pre></td></tr></table></figure><h4 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep Cgi | grep cgi | grep sg17|awk <span class="string">'&#123;printf("kill -9 %s\n", $2);&#125;'</span> | bash</span><br></pre></td></tr></table></figure><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ping //是否可达</span><br><span class="line">ping -l src -c <span class="built_in">times</span> dst //多ip情况下指定ip，<span class="built_in">times</span>表示次数</span><br></pre></td></tr></table></figure><h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet //端口是否开放</span><br></pre></td></tr></table></figure><h4 id="bg"><a href="#bg" class="headerlink" title="bg"></a>bg</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span>  //将任务放置后台</span><br></pre></td></tr></table></figure><h4 id="fg"><a href="#fg" class="headerlink" title="fg"></a>fg</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span> //将任务放置前台</span><br></pre></td></tr></table></figure><h4 id="jobs"><a href="#jobs" class="headerlink" title="jobs"></a>jobs</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span> -l  //列出任务pid</span><br></pre></td></tr></table></figure><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">history</span> | grep rm //查看删除文件历史</span><br><span class="line">/root/.bash_history //root用户所有历史记录（不同终端）</span><br></pre></td></tr></table></figure><h4 id="getconf"><a href="#getconf" class="headerlink" title="getconf"></a>getconf</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getconf WORD_BIT //获取cpu字长</span><br></pre></td></tr></table></figure><h4 id="ldd"><a href="#ldd" class="headerlink" title="ldd"></a>ldd</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd //查看动态库依赖</span><br></pre></td></tr></table></figure><h4 id="whereis-which-locate"><a href="#whereis-which-locate" class="headerlink" title="whereis which locate"></a>whereis which locate</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查看软件安装路径</span><br></pre></td></tr></table></figure><h4 id="date"><a href="#date" class="headerlink" title="date"></a>date</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date -d <span class="string">"00:00:00 2018-06-01"</span> +%s //通过日期显示时戳</span><br><span class="line">date -d @1501570226  //通过时间戳显示日期</span><br></pre></td></tr></table></figure><h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tunlp | grep 8061 查看端口被哪个进程占用</span><br></pre></td></tr></table></figure><h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-I: 第一个寻找头文件目录</span><br><span class="line">-L: 第一个寻找库文件目录</span><br><span class="line">-l: 寻找动态库或静态库</span><br><span class="line">-c: 只编译，不连接</span><br></pre></td></tr></table></figure><h4 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -s -d xx.o   //反汇编</span><br></pre></td></tr></table></figure><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">"*.cpp"</span> | xargs grep -w <span class="string">"CLog"</span>                  <span class="comment">#全词匹配查找</span></span><br><span class="line">find -name file                                              <span class="comment">#查找文件名</span></span><br><span class="line">find -iname file                                             <span class="comment">#忽略大小写</span></span><br><span class="line">find  -maxdepth file                                         <span class="comment">#最大递归深度</span></span><br><span class="line">find  -mindepth file                                         <span class="comment">#对消递归深度</span></span><br><span class="line">find  -not  file                                             <span class="comment">#相反匹配</span></span><br><span class="line">find  . -empty                                               <span class="comment">#查找空文件</span></span><br><span class="line">find  -name file -<span class="built_in">exec</span> cmd &#123;&#125; \;                             <span class="comment">#在找到的文件上执行命令</span></span><br><span class="line">find . -<span class="built_in">type</span> f                                               <span class="comment">#查找文件</span></span><br><span class="line">find ~ -size +100M/-100M                                     <span class="comment">#查找满足尺寸文件</span></span><br><span class="line">find / -<span class="built_in">type</span> f -name *.zip -size +100M -<span class="built_in">exec</span> rm -i &#123;&#125; \;     <span class="comment">#查找删除</span></span><br></pre></td></tr></table></figure><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">grep -v <span class="string">"match"</span> file                               <span class="comment">#出除含有匹配字符串之外的所有行</span></span><br><span class="line">grep  <span class="string">"match"</span> file --color=auto                    <span class="comment">#匹配字符串标颜色</span></span><br><span class="line">grep -E <span class="string">"[1-9]+"</span> file; egrep <span class="string">"[1-9]+"</span> file         <span class="comment">#正则匹配</span></span><br><span class="line">grep -o <span class="string">"match"</span> file                               <span class="comment">#只输出匹配的部分</span></span><br><span class="line">grep -c <span class="string">"match"</span> file                               <span class="comment">#输出匹配到的行数</span></span><br><span class="line">grep -b <span class="string">"match"</span> file                               <span class="comment">#匹配字符的偏移量</span></span><br><span class="line">grep -n <span class="string">"match"</span> file                               <span class="comment">#输出匹配到字符的行数</span></span><br><span class="line">grep -l <span class="string">"match"</span> file                               <span class="comment">#列出匹配到字符的文件名</span></span><br><span class="line">grep -r <span class="string">"match"</span> file                               <span class="comment">#递归搜索匹配项</span></span><br><span class="line">grep -i <span class="string">"MATCH"</span> file                               <span class="comment">#忽略大小写</span></span><br><span class="line">grep -w <span class="string">"match"</span> file                               <span class="comment">#全词匹配</span></span><br><span class="line">grep -e <span class="string">"match1"</span> -e <span class="string">"match2"</span> file                  <span class="comment">#多重匹配项</span></span><br><span class="line">grep <span class="string">"match"</span> --include *.&#123;php,html&#125;                <span class="comment">#只在目录中所有的.php和.html文件中递归搜索字符"main()"</span></span><br><span class="line">grep <span class="string">"main()"</span> . -r --exclude <span class="string">"README"</span>              <span class="comment">#在搜索结果中排除所有README文件</span></span><br><span class="line">grep 170501686 coins_20180417.log | grep <span class="string">'change pay log'</span> |grep <span class="string">',cash=-'</span> |awk -F <span class="string">'[=,]'</span> <span class="string">'&#123;a+=$12&#125; END&#123;print a&#125;'</span></span><br><span class="line">grep -E <span class="string">'act=new|act=add'</span> equipment_20180705.log | grep <span class="string">'code=get_world_battle_Kill_rewards'</span> <span class="comment">#找出包含 get_world_battle_Kill_rewards 的行，其中act=new 或act=add</span></span><br><span class="line">grep get_default_error_string /* -rFn --binary-files=without-match  <span class="comment">#只递归匹配文本文件，不匹配二进制文件中的内容</span></span><br></pre></td></tr></table></figure><h4 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">'&#123;print $1, $4&#125;'</span> netstat.txt                                                   <span class="comment">#打印1,4列</span></span><br><span class="line">awk <span class="string">'&#123;printf "%-8s %-8s %-8s %-18s %-22s %-15s\n",$1,$2,$3,$4,$5,$6&#125;'</span>  netstat.txt <span class="comment">#格式化输出</span></span><br><span class="line">awk <span class="string">'$3==0 &amp;&amp; $6=="LISTEN"'</span> netstat.txt                                            <span class="comment">#第三列的值为0 &amp;&amp; 第6列的值为LISTEN</span></span><br><span class="line">awk <span class="string">'$3 &gt; 0 &#123;print $0&#125;'</span> netstat.txt                                                <span class="comment">#第三列不为0的所有项</span></span><br><span class="line">awk <span class="string">'$3==0 &amp;&amp; $6=="LISTEN" || NR==1 '</span> netstat.txt                                  <span class="comment">#包括第一行</span></span><br><span class="line">awk <span class="string">'$3==0 &amp;&amp; $6=="LISTEN" || NR==1 &#123;printf "%-20s %-20s %s\n",$4,$5,$6&#125;'</span> netstat.txt   <span class="comment">#加上格式化输出</span></span><br><span class="line">awk <span class="string">'BEGIN&#123;FS=":"&#125;&#123;print $1, $2, $5&#125;'</span> /etc/passwd 或 awk -F: <span class="string">'&#123;print $1, $2, $5&#125;'</span> /etc/passwd  <span class="comment">#指定分隔符</span></span><br><span class="line">awk -F<span class="string">'[::]'</span> <span class="string">'&#123;print $1, $2, $5&#125;'</span> /etc/passwd                                 <span class="comment">#指定多个分割符</span></span><br><span class="line">awk <span class="string">'$6 ~ /FIN/ || NR==1 &#123;print NR,$4,$5,$6&#125;'</span> OFS=<span class="string">"\t"</span> netstat.txt       <span class="comment">#匹配FIN状态</span></span><br><span class="line">awk <span class="string">'NR!=1&#123;print &gt; $6&#125;'</span> netstat.txt                                                <span class="comment">#拆分文件</span></span><br><span class="line">awk <span class="string">'&#123;for(i=1;i&lt;=NF;i++)printf "%-22s", $i "  ";printf"\n"&#125;'</span> netstat.txt    <span class="comment">#打印出除开第一行的所有行   </span></span><br><span class="line">grep appid <span class="variable">$file</span> | awk -F <span class="string">"="</span> <span class="string">'&#123;print $3&#125;'</span> | sed <span class="string">'s/["/&gt;]//g'</span> | sed <span class="string">'s/ //g'</span> <span class="comment">#过滤掉"/&gt;和空格</span></span><br></pre></td></tr></table></figure><h4 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sed -i <span class="string">"s/my/cp/g"</span> pet.txt                                          <span class="comment">#将文件中所有的my替换成cp</span></span><br><span class="line">sed -i <span class="string">"s/^/#/g"</span> pet.txt                                            <span class="comment">#在每行最前面加#</span></span><br><span class="line">sed -i <span class="string">"s/$/---/g"</span> pet.txt                                          <span class="comment">#在每行最有面加---</span></span><br><span class="line">sed -i <span class="string">'s/&lt;[^&gt;]*&gt;//g'</span> html.txt                                      <span class="comment">#去掉某html中的tags</span></span><br><span class="line">sed -i <span class="string">"3s/my/your/g"</span> pets.txt                                      <span class="comment">#替换第3行以后的my</span></span><br><span class="line">sed -i <span class="string">"3,6s/my/your/g"</span> pets.txt                                    <span class="comment">#只替换3到6行的my</span></span><br><span class="line">sed -i <span class="string">'s/s/S/1'</span> my.txt                                             <span class="comment">#只替换每一行的第一个s</span></span><br><span class="line">sed -i -e <span class="string">'1,3s/my/your/g'</span> -e <span class="string">'3,$s/This/That/g'</span> my.txt             <span class="comment">#1到3行换成your, 3行以后换成That </span></span><br><span class="line">sed -i s/1527696000/1528560000/g ./s*/conf/ActivityTime.json</span><br></pre></td></tr></table></figure><h4 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof  -p PID  | wc -l  <span class="comment">#查看进程打开的文件数量</span></span><br><span class="line">lsof  -p PID  |awk <span class="string">'&#123;print $2&#125;'</span>|sort | uniq -c | awk <span class="string">'&#123;sum += $1&#125; END&#123;print sum&#125;'</span> <span class="comment">#查看进程打开的文件数量</span></span><br><span class="line">lsof -i :port  <span class="comment">#查看某个端口的连接情况</span></span><br><span class="line">watch <span class="string">"losf -p PID | wc -l"</span>  <span class="comment">#查看进程打开文件数量的变化情况</span></span><br></pre></td></tr></table></figure><h4 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr  //查看ip地址（可显示mac地址和网卡名称）</span><br></pre></td></tr></table></figure><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"?"</span>  匹配单个字符串</span><br><span class="line"><span class="string">"*"</span>  匹配字符串序列</span><br></pre></td></tr></table></figure><h4 id="正则"><a href="#正则" class="headerlink" title="正则　　"></a>正则　　</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    ERE BRE</span><br><span class="line">    <span class="string">"."</span>  任意单个字符</span><br><span class="line">    <span class="string">"*"</span>  匹配任一字符的任意长度</span><br><span class="line">    <span class="string">"^"</span> 以xx开始字符</span><br><span class="line">    <span class="string">"$"</span> 以xx结尾字符</span><br><span class="line">    <span class="string">"[]"</span> 字符集合</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 实战　  </span></span><br><span class="line">终端遍历目录导入数据库  </span><br><span class="line">终端中执行　　</span><br><span class="line">```sh</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(ls sg17_s*); <span class="keyword">do</span> $(mysql -u root -p $(basename <span class="variable">$i</span> .sql) &lt; <span class="variable">$i</span>);<span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>将所有db.conf 中的密码替换　　　</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ./ -name db.conf | xargs sed -i <span class="string">'s/password\ =\ 1234/password\ =\ Ujg5-bc@0520/g'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>go</title>
    <link href="http://yoursite.com/2020/07/04/go/"/>
    <id>http://yoursite.com/2020/07/04/go/</id>
    <published>2020-07-04T07:26:14.000Z</published>
    <updated>2020-07-06T13:03:58.392Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>  <h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><ul><li><p>个人<br><img src="/images/go_20200706_p1.png" alt="p1"></p></li><li><p>公司<br><img src="/images/go_20200706_p2.png" alt="p2"></p></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> fmt -w *.<span class="keyword">go</span>   <span class="comment">//格式化代码 </span></span><br><span class="line"><span class="keyword">go</span> fmt github.com/hello   </span><br><span class="line"><span class="keyword">go</span> run  src/xx/xx.<span class="keyword">go</span>  <span class="comment">//编译+执行</span></span><br><span class="line"><span class="keyword">go</span> build -o /bin/test /src/test  <span class="comment">//编译生成二进制文件， -o指定目录</span></span><br><span class="line"><span class="keyword">go</span> build  github.com/xx   <span class="comment">//注意src目录不用写</span></span><br><span class="line"><span class="keyword">go</span> install  github.com/xx  <span class="comment">//生成可执行文件到bin目录下</span></span><br><span class="line"><span class="keyword">go</span> env <span class="comment">//显示环境变量</span></span><br><span class="line"><span class="keyword">go</span> get <span class="comment">//安装第三方包</span></span><br></pre></td></tr></table></figure><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符以字母或下划线开头，大小写敏感  </p><h2 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h2><p>break default func interface select case defer go map struct chan else goto package switch<br>const fallthough &nbsp;if range &nbsp;type &nbsp;continue for import return var   </p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="包的别名"><a href="#包的别名" class="headerlink" title="包的别名"></a>包的别名</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(  </span><br><span class="line">    a  <span class="string">"fmt"</span>  <span class="comment">//a是fmt的别名  </span></span><br><span class="line">)  </span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 初始化  </span></span><br><span class="line"><span class="string">* init函数  </span></span><br><span class="line"><span class="string">每个源文件都有一个init函数， 在main函数调用之前会执行init  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span>  </span><br><span class="line"><span class="keyword">import</span>(  </span><br><span class="line">_ <span class="string">"test"</span>  <span class="comment">//仅初始化， 不使用包里面的东西  </span></span><br><span class="line">)  </span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">嵌套包的初始化顺序， 最里层包先初始化     </span></span><br><span class="line"><span class="string">![p1](/data/colin/blog/source/images/go_20200408_1.png)  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 数据类型  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">int8</span> <span class="keyword">int16</span> <span class="keyword">int32</span> <span class="keyword">int64</span> <span class="keyword">uint8</span> <span class="keyword">uint16</span> <span class="keyword">uint32</span> <span class="keyword">uint64</span> <span class="keyword">float32</span> <span class="keyword">float64</span></span><br></pre></td></tr></table></figure><h3 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h3><p>以字母或_开头, 后面跟着字母,_或数字  </p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> <span class="keyword">default</span> <span class="function"><span class="keyword">func</span> <span class="title">interface</span> <span class="title">select</span> <span class="title">case</span> <span class="title">defer</span> <span class="title">go</span> <span class="title">map</span> <span class="title">struct</span></span> </span><br><span class="line"><span class="keyword">chan</span> <span class="keyword">else</span> <span class="keyword">goto</span> <span class="keyword">package</span> <span class="keyword">switch</span> <span class="keyword">const</span> fallthough  <span class="keyword">if</span> <span class="keyword">range</span> <span class="keyword">type</span> </span><br><span class="line"><span class="keyword">continue</span> <span class="keyword">for</span> <span class="keyword">import</span> <span class="keyword">return</span> <span class="keyword">var</span></span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>编译时已经确定, const修饰，只读<br>常量必须要赋值   </p><pre><code class="go"><span class="keyword">const</span> 只能修饰boolean, number(<span class="keyword">int</span>相关， 浮点， <span class="built_in">complex</span>)和<span class="keyword">string</span>  <span class="keyword">const</span> b <span class="keyword">string</span> = <span class="string">"hello word"</span>  <span class="keyword">const</span> b = <span class="string">"hello word"</span>  <span class="keyword">const</span> c = getValue()  <span class="comment">//错误，与c++不同  </span><span class="comment">//优雅的写法  </span><span class="keyword">const</span>(      a = <span class="number">0</span>      b = <span class="number">1</span>      c = <span class="number">2</span>     d     <span class="comment">//2 </span>)  <span class="comment">//更加专业的写法 </span><span class="keyword">const</span>(      a = <span class="literal">iota</span> <span class="comment">//0  </span>    b  <span class="comment">//1  </span>    c   <span class="comment">//2  </span>)  <span class="keyword">const</span>(      a = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">//1</span>    b  <span class="comment">//2 </span>    c   <span class="comment">//4  </span>)  <span class="keyword">const</span>(    a  = <span class="literal">iota</span>  <span class="comment">//0</span>    b          <span class="comment">//1 </span>    c          <span class="comment">//2 </span>    d  = <span class="number">8</span>    <span class="comment">//8  </span>    e         <span class="comment">//8 </span>    f  = <span class="literal">iota</span> <span class="comment">//5</span>    g         <span class="comment">//6</span>)</code></pre><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code class="go"><span class="comment">//第一种写法</span><span class="keyword">var</span> identifier <span class="keyword">type</span>  <span class="keyword">var</span> a <span class="keyword">int</span>  <span class="keyword">var</span> b <span class="keyword">string</span>  <span class="keyword">var</span> c <span class="keyword">bool</span>  d <span class="keyword">int</span> = <span class="number">8</span>  e <span class="keyword">string</span> = <span class="string">"hello world"</span>  <span class="comment">//第二种写法</span>Var(      a <span class="keyword">int</span>  <span class="comment">//默认0  </span>    b <span class="keyword">string</span> <span class="comment">//默认""  </span>    c <span class="keyword">bool</span> <span class="comment">//默认false  </span>    d = <span class="number">8</span>      e = <span class="string">"hello world"</span>  )  </code></pre><h3 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h3><p>值类型： 基本数据类型int, float, bool, string以及数组和struct，内存在栈中分配<br>引用类型： 指针, slice, map, chan, interface等， 内存在对上分配，GC回收  </p><p>变量的作用域<br>局部变量–生命周期在函数内或语句块内<br>全局变量–生命周期在整个包，大写的可以外部访问<br> a :=1 实际是两条语句: var a int a = 1 go中不能在函数外赋值，所以:= 不能用于函数外   </p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h3 id="指针类型"><a href="#指针类型" class="headerlink" title="指针类型"></a>指针类型</h3><p>var p *int = &amp;a  </p><h3 id="类型转化"><a href="#类型转化" class="headerlink" title="类型转化"></a>类型转化</h3><p>type(var)<br>int 和 int32是不同类型， 不能直接运算  </p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>两种表示方式：<br>1.”” 允许转义<br>2.`` 原生字符串，允许换行  </p><pre><code class="go">strings  strings.HasPrefix(s <span class="keyword">string</span>, prefix <span class="keyword">string</span>) <span class="keyword">bool</span>：判断字符串s是否以prefix开头  strings.HasSuffix(s <span class="keyword">string</span>, suffix <span class="keyword">string</span>) <span class="keyword">bool</span>：判断字符串s是否以suffix结尾。  strings.Index(s <span class="keyword">string</span>, str <span class="keyword">string</span>) <span class="keyword">int</span>：判断str在s中首次出现的位置，如果没有出现，则返回<span class="number">-1</span>  strings.LastIndex(s <span class="keyword">string</span>, str <span class="keyword">string</span>) <span class="keyword">int</span>：判断str在s中最后出现的位置，如果没有出现，则返回<span class="number">-1</span>  strings.Replace(str <span class="keyword">string</span>, old <span class="keyword">string</span>, <span class="built_in">new</span> <span class="keyword">string</span>, n <span class="keyword">int</span>)：字符串替换  strings.Count(str <span class="keyword">string</span>, substr <span class="keyword">string</span>)<span class="keyword">int</span>：字符串计数  strings.ToLower(str <span class="keyword">string</span>)<span class="keyword">string</span>：转为小写  strings.ToUpper(str <span class="keyword">string</span>)<span class="keyword">string</span>：转为大写  strings.TrimSpace(str <span class="keyword">string</span>)：去掉字符串首尾空白字符  strings.Trim(str <span class="keyword">string</span>, cut <span class="keyword">string</span>)：去掉字符串首尾cut字符  strings.TrimLeft(str <span class="keyword">string</span>, cut <span class="keyword">string</span>)：去掉字符串首cut字符  strings.TrimRight(str <span class="keyword">string</span>, cut <span class="keyword">string</span>)：去掉字符串尾cut字符  strings.Field(str <span class="keyword">string</span>)：返回str空格分隔的所有子串的slice  strings.Split(str <span class="keyword">string</span>, split <span class="keyword">string</span>)：返回str split分隔的所有子串的slice  strings.Join(s1 []<span class="keyword">string</span>, sep <span class="keyword">string</span>)：用sep把s1中的所有元素链接起来  strconv.Itoa(i <span class="keyword">int</span>)：把一个整数i转成字符串  strconv.Atoi(str <span class="keyword">string</span>)(<span class="keyword">int</span>, error)：把一个字符串转成整数  </code></pre><h2 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h2><pre><code class="go">获取当前时间， now := time.Now()  time.Now().Day()，time.Now().Minute()，time.Now().Month()，time.Now().Year()  格式化，fmt.Printf(“%<span class="number">02</span>d/%<span class="number">02</span>d%<span class="number">02</span>d %<span class="number">02</span>d:%<span class="number">02</span>d:%<span class="number">02</span>d”, now.Year()…)  time.Duration用来表示纳秒  一些常量：  <span class="keyword">const</span> (    Nanosecond  Duration = <span class="number">1</span>    Microsecond          = <span class="number">1000</span> * Nanosecond    Millisecond          = <span class="number">1000</span> * Microsecond    Second               = <span class="number">1000</span> * Millisecond    Minute               = <span class="number">60</span> * Second    Hour                 = <span class="number">60</span> * Minute  )  格式化:  now := time.Now()  fmt.Println(now.Format(“<span class="number">02</span>/<span class="number">1</span>/<span class="number">2006</span> <span class="number">15</span>:<span class="number">04</span>”))  fmt.Println(now.Format(“<span class="number">2006</span>/<span class="number">1</span>/<span class="number">02</span> <span class="number">15</span>:<span class="number">04</span>”))  fmt.Println(now.Format(“<span class="number">2006</span>/<span class="number">1</span>/<span class="number">02</span>”))  </code></pre><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><pre><code class="go"><span class="keyword">if</span>  (<span class="number">1</span>) <span class="keyword">if</span> condition {       }  (<span class="number">2</span>) <span class="keyword">if</span> condition {      } <span class="keyword">else</span> {      }  (<span class="number">3</span>) <span class="keyword">if</span> condition1 {        } <span class="keyword">else</span> <span class="keyword">if</span> condition2 {        } <span class="keyword">else</span> <span class="keyword">if</span> condition3 {        } <span class="keyword">else</span> {        }  错误代码：      <span class="keyword">if</span> condition {      }      <span class="keyword">else</span>{     <span class="comment">//else必须和上一个}在一行否则编译不过去  </span>    }   <span class="keyword">switch</span>  （<span class="number">1</span>）<span class="keyword">switch</span> <span class="keyword">var</span> {          <span class="keyword">case</span> var1:          <span class="keyword">fallthrough</span> <span class="comment">//继续往下执行  </span>        <span class="keyword">case</span> var2:          <span class="keyword">case</span> var3:          <span class="keyword">default</span>:      }  <span class="comment">//注意没有break  </span>（<span class="number">2</span>）<span class="keyword">switch</span> <span class="keyword">var</span> {          <span class="keyword">case</span> var1, var2: <span class="comment">//多条件在一行  </span>        <span class="keyword">case</span> <span class="keyword">var</span> <span class="number">3</span>:          <span class="keyword">default</span>:          }    (<span class="number">3</span>) <span class="keyword">switch</span>{  <span class="comment">//没有变量  </span>            condition1:              condition2:              <span class="keyword">default</span>:          }    (<span class="number">4</span>) <span class="keyword">switch</span> 语句块 {              ...          }   <span class="keyword">for</span>   (<span class="number">1</span>) <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>;  i++{  <span class="comment">//注意for没有()  </span>               ...         }   (<span class="number">2</span>)  <span class="keyword">for</span> 条件{         }   (<span class="number">3</span>) fro <span class="keyword">range</span>      str := “hello world,中国”      <span class="keyword">for</span> i, v := <span class="keyword">range</span> str {          fmt.Printf(“index[%d] val[%c] <span class="built_in">len</span>[%d]\n”, i, v, <span class="built_in">len</span>([]<span class="keyword">byte</span>(v)))      }  </code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>不支持重载，一个包不能有两个名字一样的函数<br>函数是一等公民，函数也是一种类型，一个函数可以赋值给变量<br>匿名函数<br>多返回值  </p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>当函数返回时，执行defer语句。因此，可以用来做资源清理<br>多个defer语句，按先进后出的方式执行<br>defer语句中的变量，在defer声明时就决定了  </p><ul><li>关闭文件句柄  <pre><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> {    file := open(filename)    <span class="keyword">defer</span> file.Close()  <span class="comment">//文件操作  </span>}  </code></pre></li><li>锁资源释放  <pre><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> {    mc.Lock()    <span class="keyword">defer</span> mc.Unlock()    <span class="comment">//其他操作  </span>}  </code></pre></li><li>数据库连接释放  <pre><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> {    conn := openDatabase()    <span class="keyword">defer</span> conn.Close()    <span class="comment">//其他操作  </span>}  </code></pre></li></ul><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><pre><code class="go">不需要导入包  <span class="built_in">close</span>：主要用来关闭channel  <span class="built_in">len</span>：用来求长度，比如<span class="keyword">string</span>、array、slice、<span class="keyword">map</span>、channel  <span class="built_in">new</span>：用来分配内存，主要用来分配值类型，比如<span class="keyword">int</span>、<span class="keyword">struct</span>。返回的是指针  <span class="built_in">make</span>：用来分配内存，主要用来分配引用类型，比如<span class="keyword">chan</span>、<span class="keyword">map</span>、slice  <span class="built_in">append</span>：用来追加元素到数组、slice中  <span class="built_in">panic</span>和<span class="built_in">recover</span>：用来做错误处理  </code></pre><ul><li>new和make的区别<br><img src="/data/colin/blog/source/images/go_20200408_2.png" alt="p2">  </li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code class="go"><span class="keyword">var</span> a [<span class="built_in">len</span>]<span class="keyword">int</span>，比如：<span class="keyword">var</span> a[<span class="number">5</span>]<span class="keyword">int</span>  长度是数组类型的一部分，因此，<span class="keyword">var</span> a[<span class="number">5</span>] <span class="keyword">int</span>和<span class="keyword">var</span> a[<span class="number">10</span>]<span class="keyword">int</span>是不同的类型  数组可以通过下标进行访问，下标是从<span class="number">0</span>开始，最后一个元素下标是：<span class="built_in">len</span><span class="number">-1</span>  访问越界，如果下标在数组合法范围之外，则触发访问越界，会<span class="built_in">panic</span>  数组是值类型，因此改变副本的值，不会改变本身的值  初始化  <span class="keyword">var</span> age0 [<span class="number">5</span>] <span class="keyword">int</span> = [<span class="number">5</span>] <span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>}  <span class="keyword">var</span> age1 = [<span class="number">5</span>]<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}  <span class="keyword">var</span> age2 = [...]<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>}  <span class="keyword">var</span> str = [<span class="number">5</span>]<span class="keyword">string</span>{<span class="number">3</span>:”hello world”, <span class="number">4</span>:”tom”} <span class="comment">//指定索引赋值  </span>多维数组  <span class="keyword">var</span> age [<span class="number">5</span>][<span class="number">3</span>] <span class="keyword">int</span>  <span class="keyword">var</span> age [<span class="number">5</span>][<span class="number">3</span>] <span class="keyword">int</span> = [...][<span class="number">3</span>]<span class="keyword">int</span>&lt;!--￼<span class="number">3</span>--&gt;  </code></pre><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><pre><code class="go">切片是数组的一个引用，因此切片是引用类型  切片的长度可以改变，因此，切片是一个可变的数组  <span class="built_in">cap</span>可以求出slice最大的容量，<span class="number">0</span> &lt;= <span class="built_in">len</span>(slice) &lt;= <span class="built_in">cap</span>(array)，其中array  切片的定义：<span class="keyword">var</span> 变量名 []类型，比如 <span class="keyword">var</span> str []<span class="keyword">string</span>  <span class="keyword">var</span> arr []<span class="keyword">int</span>  切片初始化：<span class="keyword">var</span> slice []<span class="keyword">int</span> = arr[start:end]          包含start到end之间的元素，但不包含end  <span class="keyword">var</span> slice []<span class="keyword">int</span> = arr[<span class="number">0</span>:end]可以简写为 <span class="keyword">var</span> slice []<span class="keyword">int</span>=arr[:end]  <span class="keyword">var</span> slice []<span class="keyword">int</span> = arr[start:<span class="built_in">len</span>(arr)] 可以简写为 <span class="keyword">var</span> slice[]<span class="keyword">int</span> = arr[start:]  <span class="keyword">var</span> slice []<span class="keyword">int</span> = arr[<span class="number">0</span>, <span class="built_in">len</span>(arr)] 可以简写为 <span class="keyword">var</span> slice[]<span class="keyword">int</span> = arr[:]  如果要切片最后一个元素去掉，可以这么写          slice = slice[:<span class="built_in">len</span>(slice)<span class="number">-1</span>]  </code></pre><ul><li><p>切片的内存布局<br><img src="/data/colin/blog/source/images/go_20200408_3.png" alt="p3">  </p></li><li><p>切片的创建   </p><pre><code class="go"><span class="keyword">var</span> slice []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)           slice  := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)           slice  := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>, <span class="built_in">cap</span>)  <span class="keyword">var</span>  s = []<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>, <span class="number">3</span>}  a := [...]<span class="keyword">int</span>{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}  s := a[:]  </code></pre><p><img src="/data/colin/blog/source/images/go_20200408_4.png" alt="p4">  </p></li></ul><h3 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h3><pre><code class="go">用<span class="built_in">append</span>内置函数操作切片  <span class="keyword">for</span> <span class="keyword">range</span> 遍历切片  切片resize  <span class="keyword">var</span> a = []<span class="keyword">int</span> {<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>}  b := a[<span class="number">1</span>:<span class="number">2</span>]  b = b[<span class="number">0</span>:<span class="number">3</span>]  </code></pre><ul><li><p>切片拷贝<br>copy, append  </p></li><li><p>string与slice<br>string底层就是一个byte的数组，因此，也可以进行切片操作  </p><pre><code class="go">str := “hello world”  s1 := str[<span class="number">0</span>:<span class="number">5</span>]  fmt.Println(s1)  s2 := str[<span class="number">5</span>:]  fmt.Println(s2)  </code></pre></li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><pre><code class="go">key-value的数据结构，又叫字典或关联数组  申明 : 声明是不会分配内存的，初始化需要<span class="built_in">make</span>   <span class="keyword">var</span> map1 <span class="keyword">map</span>[keytype]valuetype   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>   <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>  <span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>{“hello”: “world”}  a = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>, <span class="number">10</span>)  a[“hello”] = “world”            <span class="comment">//插入和更新  </span>Val, ok := a[“hello”]           <span class="comment">//查找  </span><span class="keyword">for</span> k, v := <span class="keyword">range</span> a {           <span class="comment">//遍历  </span>fmt.Println(k,v)  }  <span class="built_in">delete</span>(a, “hello”)              <span class="comment">//删除  </span><span class="built_in">len</span>(a)                          <span class="comment">//长度  </span><span class="comment">//slice of map  </span>Items := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">int</span>][<span class="keyword">int</span>], <span class="number">5</span>)  For I := <span class="number">0</span>; I &lt; <span class="number">5</span>; i++ {          items[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][<span class="keyword">int</span>])  }  </code></pre><ul><li><p>排序<br>map中key值是无序的<br>a. 先获取所有key，把key进行排序<br>b. 按照排序好的key，进行遍历  </p></li><li><p>翻转<br>初始化另外一个map，把key、value互换即可  </p></li></ul><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul><li>线程同步<br>a. import(“sync”)<br>b. 互斥锁, var mu sync.Mutex<br>c. 读写锁, var mu sync.RWMutex  </li></ul><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p>用来自定义复杂数据结构<br>struct里面可以包含多个字段（属性）<br>struct类型可以定义方法，注意和函数的区分<br>struct类型是值类型<br>struct类型可以嵌套<br>Go语言没有class类型，只有struct类型<br>golang中的struct没有构造函数，一般可以使用工厂模式来解决这个问题  </p><pre><code class="go">Package model  <span class="keyword">type</span> student <span class="keyword">struct</span> {         Name stirng      Age <span class="keyword">int</span>  }  <span class="function"><span class="keyword">func</span> <span class="title">NewStudent</span><span class="params">(name <span class="keyword">string</span>, age <span class="keyword">int</span>)</span> *<span class="title">student</span></span> {  <span class="keyword">return</span> &amp;student{         Name:name,         Age:age,  }  }  Package main  S := <span class="built_in">new</span> (student)  S := model.NewStudent(“tony”, <span class="number">20</span>)  </code></pre><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><pre><code class="go"><span class="keyword">type</span> Student <span class="keyword">struct</span>{      Name <span class="keyword">string</span>      Next *Student  }  </code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>Golang中的方法是作用在特定类型的变量上，因此自定义类型，都可以有方法，而不仅仅是struct<br>定义：func (recevier type) methodName(参数列表)(返回值列表){}  </p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>通过匿名字段来实现   </p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Interface类型可以定义一组方法，但是这些不需要实现。并且interface不能包含任何变量<br>如果一个变量含有了多个interface类型的方法，那么这个变量就实现了多个接口<br>如果一个变量只含有了1个interface的方部分方法，那么这个变量没有实现这个接口  </p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言，由于接口是一般类型，不知道具体类型，如果要转成具体类型可以采用以下方法进行转换  </p><pre><code class="go"><span class="keyword">var</span> t <span class="keyword">int</span>  <span class="keyword">var</span> x <span class="keyword">interface</span>{}  x = t  y, ok = x.(<span class="keyword">int</span>)   <span class="comment">//转成int，带检查  </span></code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><pre><code class="go">可以在运行时动态获取变量的相关信息  <span class="keyword">import</span> (“reflect”)  reflect.TypeOf，获取变量的类型，返回reflect.Type类型  reflect.ValueOf，获取变量的值，返回reflect.Value类型  reflect.Value.Kind，获取变量的类别，返回一个常量  reflect.Value.Interface()，转换成<span class="keyword">interface</span>{}类型  reflect.Value.Kind()方法返回的常量  </code></pre><p><img src="/data/colin/blog/source/images/go_20200408_5.png" alt="p5">  </p><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><pre><code class="go">终端读写  os.Stdin：标准输入  os.Stdout：标准输出  os.Stderr：标准错误输出  文件写入  os.OpenFile(“output.dat”,  os.O_WRONLY|os.O_CREATE, <span class="number">0666</span>)  第二个参数：文件打开模式：  <span class="number">1.</span> os.O_WRONLY：只写  <span class="number">2.</span> os.O_CREATE：创建文件  <span class="number">3.</span> os.O_RDONLY：只读  <span class="number">4.</span>  os.O_RDWR：读写  <span class="number">5.</span>  os.O_TRUNC ：清空  第三个参数：权限控制：  r ——&gt; <span class="number">004</span>  w——&gt; <span class="number">002</span>  x——&gt; <span class="number">001</span>  命令行参数  os.Args是一个<span class="keyword">string</span>的切片，用来存储所有的命令行参数  </code></pre><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><pre><code class="go">导入包：<span class="keyword">import</span> “encoding/json”  序列化: json.Marshal(data <span class="keyword">interface</span>{})  反序列化: json.UnMarshal(data []<span class="keyword">byte</span>,  v  <span class="keyword">interface</span>{})  </code></pre><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>不同goroutine之间如何通信  </p><ul><li>全局变量和锁同步  </li><li>Channel<br>类似unix中的管道<br>先进先出<br>线程安全, 多个goroutine同时访问, 不需要加锁<br>channel是有类型的, 一个整数的channel只能存放整数<br>channel带缓冲区  </li></ul><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>文件名必须以_test.go结尾<br>函数名必须以Test开头</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;  
&lt;h2 id=&quot;项目构建&quot;&gt;&lt;a href=&quot;#项目构建&quot; class=&quot;headerlink&quot; title=&quot;项目构建&quot;&gt;&lt;/a&gt;项目构建&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;个人&lt;br&gt;&lt;img src=&quot;/images/go_202007
      
    
    </summary>
    
    
      <category term="go" scheme="http://yoursite.com/categories/go/"/>
    
    
  </entry>
  
  <entry>
    <title>linux内核实战</title>
    <link href="http://yoursite.com/2020/05/07/linux%E5%86%85%E6%A0%B8%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2020/05/07/linux%E5%86%85%E6%A0%B8%E5%AE%9E%E6%88%98/</id>
    <published>2020-05-07T08:13:54.000Z</published>
    <updated>2020-07-04T11:13:27.975Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>  <h3 id="内核C中结构体初始化"><a href="#内核C中结构体初始化" class="headerlink" title="内核C中结构体初始化"></a>内核C中结构体初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __percpu       __attribute__((noderef, address_space(3)))</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">As</span>&#123;</span> </span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">gdt</span>[2];</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PER_CPU_DEF_ATTRIBUTES</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_AS \</span></span><br><span class="line">        __percpu PER_CPU_DEF_ATTRIBUTES \</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">As</span> </span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">main</span>()&#123;</span></span><br><span class="line">    <span class="comment">//struct As ss =&#123;.gdt=&#123;[0]=&#123;.a= 1, .b = 2&#125;, [1]=&#123;.a=3, .b=4&#125;&#125;&#125;;</span></span><br><span class="line">    DEFINE_AS ss =&#123;.gdt=&#123;[<span class="number">0</span>]=&#123;.a= <span class="number">1</span>, .b = <span class="number">2</span>&#125;, [<span class="number">1</span>]=&#123;.a=<span class="number">3</span>, .b=<span class="number">4</span>&#125;&#125;&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ss.gdt[<span class="number">0</span>].a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;  

&lt;h3 id=&quot;内核C中结构体初始化&quot;&gt;&lt;a href=&quot;#内核C中结构体初始化&quot; class=&quot;headerlink&quot; title=&quot;内核C中结构体初始化&quot;&gt;&lt;/a&gt;内核C中结构体初始化&lt;/h3&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux内核" scheme="http://yoursite.com/tags/Linux%E5%86%85%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>muduo笔记</title>
    <link href="http://yoursite.com/2020/04/04/muduo%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/04/muduo%E7%AC%94%E8%AE%B0/</id>
    <published>2020-04-04T01:10:21.000Z</published>
    <updated>2020-07-04T06:53:07.803Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a> <ul><li>non-blocking 和 IO multiplexing 一起使用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt; 
&lt;ul&gt;
&lt;li&gt;non-blocking 和 IO multiplexing 一起使用&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="网络编程" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>linux系统编程</title>
    <link href="http://yoursite.com/2020/03/30/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/03/30/linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/</id>
    <published>2020-03-30T01:02:55.000Z</published>
    <updated>2020-03-30T01:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>  <h3 id="exec函数簇和system区别"><a href="#exec函数簇和system区别" class="headerlink" title="exec函数簇和system区别"></a>exec函数簇和system区别</h3><p>exec是新进程复制原来的进程， pid不变， exec后的代码不会被执行   </p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程会清理环境变量， 所以守护进程中使用exec执行系统命令时最好加上绝对路径  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;  
&lt;h3 id=&quot;exec函数簇和system区别&quot;&gt;&lt;a href=&quot;#exec函数簇和system区别&quot; class=&quot;headerlink&quot; title=&quot;exec函数簇和system区别&quot;&gt;&lt;/a&gt;exec函数簇和system区别&lt;/
      
    
    </summary>
    
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
  </entry>
  
  <entry>
    <title>模板</title>
    <link href="http://yoursite.com/2020/03/29/%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2020/03/29/%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-03-29T02:24:59.000Z</published>
    <updated>2020-04-25T08:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>定义模板是不会生成代码，只有当实例化时才会生成  </p><h3 id="类型模板参数"><a href="#类型模板参数" class="headerlink" title="类型模板参数"></a>类型模板参数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">add</span>(<span class="title">T</span> <span class="title">a</span>, <span class="title">T</span> <span class="title">b</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><p>非类型是指不是泛型， 即基本类型<br>即显示使用&lt;&gt;指定<br>非类型模板参数必须是常量， 因为模板代码在编译期生成</p><ul><li>所有参数都是非类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> a, <span class="keyword">int</span> b&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add&lt;<span class="number">1</span>, <span class="number">2</span>&gt;() <span class="comment">//显示指定参数</span></span><br></pre></td></tr></table></figure></li><li>非类型和类型参数混合<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">a</span> , <span class="title">int</span> <span class="title">b</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">add</span>(<span class="title">T</span> <span class="title">c</span>)&#123;</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)c + a + b;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add&lt;<span class="keyword">int</span>, <span class="number">1</span>, <span class="number">2</span>&gt;(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li>非类型模板也可以不用&lt;&gt;指定<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> L1, <span class="keyword">unsigned</span> L1&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strcomp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>(&amp;p1)[L1], <span class="keyword">const</span> <span class="keyword">char</span>(&amp;p2)[L2])</span></span>&#123;  <span class="comment">//数组的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">strcomp(<span class="string">"test"</span>, <span class="string">"test2"</span>); <span class="comment">//字符串长度由编译器默认推到</span></span><br><span class="line">strcomp&lt;<span class="number">5</span>, <span class="number">6</span>&gt;(<span class="string">"test"</span>, <span class="string">"test2"</span>); <span class="comment">//也可以显示指定</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><p>类模板编译器不能自动推导参数所以要显示用&lt;&gt;指定  </p><h3 id="类模板成员函数"><a href="#类模板成员函数" class="headerlink" title="类模板成员函数"></a>类模板成员函数</h3><ul><li><p>定义在类内部不用写类型参数   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>定义在类外部   </p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">A</span>&lt;T&gt;:</span>:func()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非类型模板参数-1"><a href="#非类型模板参数-1" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h3><p>非类型参数不能是浮点数和类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">V</span> = 100&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">A</span>&lt;T, V&gt;:</span>:func()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="typename使用场景"><a href="#typename使用场景" class="headerlink" title="typename使用场景"></a>typename使用场景</h2><ul><li>模板类型参数   </li><li>使用类的类型成员， 用typename来标示这个类型<br>一般使用::后面跟类型时，编译器默认会当作类的成员变量。为防止这种情况使用必须使用typename(这里不能使用class代替)    </li></ul><p>例1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">mystring</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> T* Iterator;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">mystring</span>&lt;T&gt;:</span>:Iterator mystring&lt;T&gt;::begin()&#123;</span><br><span class="line">    <span class="comment">//....    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉单例模式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CHSingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    CHSingleton()</span><br><span class="line">    &#123;</span><br><span class="line">        _destory.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~CHSingleton()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">Instance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _instance; &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CDestory</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CDestory()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"CDestory"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~CDestory()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~CDestory"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">delete</span> CHSingleton::_instance;</span><br><span class="line">            CHSingleton::_instance = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="keyword">static</span> T *_instance;</span><br><span class="line">    <span class="keyword">static</span> CDestory _destory;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">thread_local</span> <span class="title">T</span> *<span class="title">CHSingleton</span>&lt;T&gt;:</span>:_instance = <span class="keyword">new</span> T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">typename</span> <span class="title">CHSingleton</span>&lt;T&gt;:</span>:CDestory CHSingleton&lt;T&gt;::_destory;</span><br></pre></td></tr></table></figure><h2 id="可调用对象做函数模板的默认参数"><a href="#可调用对象做函数模板的默认参数" class="headerlink" title="可调用对象做函数模板的默认参数"></a>可调用对象做函数模板的默认参数</h2><p>c++11以后支持模板函数默认参数  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Func</span>=<span class="title">func1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">tfunc</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">i</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">j</span>, <span class="title">Func</span> <span class="title">f</span>= <span class="title">func1</span>)&#123;</span></span><br><span class="line">    f(i, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">O</span>=<span class="title">Obj</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">tfunc</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">i</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">j</span>, <span class="title">O</span> <span class="title">o</span>= <span class="title">Obj</span>())&#123;</span></span><br><span class="line">    o(i, j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="成员函数模板"><a href="#成员函数模板" class="headerlink" title="成员函数模板"></a>成员函数模板</h2><p>成员函数模板不能是虚函数， </p><h3 id="普通类的成员函数模板"><a href="#普通类的成员函数模板" class="headerlink" title="普通类的成员函数模板"></a>普通类的成员函数模板</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">func</span>(<span class="title">T</span> <span class="title">t</span>)&#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">a.func(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="类模板中的成员函数模板"><a href="#类模板中的成员函数模板" class="headerlink" title="类模板中的成员函数模板"></a>类模板中的成员函数模板</h3><ul><li>类成员模板函数定义在类内   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">A</span>(<span class="title">T1</span> <span class="title">a</span>, <span class="title">T2</span> <span class="title">b</span>)&#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T3</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">func</span>(<span class="title">T3</span> <span class="title">c</span>)&#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    C c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">a.func(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li>类成员模板函数定义在类外  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp&lt;<span class="class"><span class="keyword">class</span> <span class="title">C</span>&gt;  //先写类模板申明</span></span><br><span class="line"><span class="class"><span class="title">temp</span>&lt;class T1, class T2&gt; //再写成员函数模板申明 </span></span><br><span class="line"><span class="class"><span class="title">A</span>&lt;C&gt;:</span>:A(T1 a, T2 b)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板显式实例化"><a href="#模板显式实例化" class="headerlink" title="模板显式实例化"></a>模板显式实例化</h2>为防止多个cpp文件中实例化相同的模板类， c++11中使用显示实例化解决<br>每种类型的模板只需实例化一次， 其他的cpp文件声明就行， 只有使用到该类型模板才用实例化  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.cpp</span></span><br><span class="line"><span class="keyword">template</span>  A&lt;<span class="keyword">float</span>&gt;;  <span class="comment">//显式实例化类</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>  <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>;<span class="comment">//显示实例化函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//b.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> A&lt;<span class="keyword">float</span>&gt;; <span class="comment">//显式实例化类声明</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span>  <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>;<span class="comment">//显示实例化函数申明</span></span><br></pre></td></tr></table></figure>类模板的实例化会实例化类模板的所有成员函数， 包括内联和类成员模板函数(vs中)    </li></ul><h2 id="using-定义模板别名"><a href="#using-定义模板别名" class="headerlink" title="using 定义模板别名"></a>using 定义模板别名</h2><ul><li>定义一个值为任意参数的模板别名  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">s_map</span> = <span class="title">std</span>:</span>:<span class="built_in">map</span>&lt;<span class="built_in">string</span>, T&gt;;</span><br><span class="line"></span><br><span class="line">s_map&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">m.insert(&#123;<span class="string">"first"</span>, <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></li><li>定义一个函数指针模板<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">using</span> <span class="title">funcptr</span> = <span class="title">bool</span> (*)(<span class="title">T</span>, <span class="title">T</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">funcptr&lt;<span class="keyword">int</span>&gt; f_ptr;</span><br><span class="line">f_ptr = func;</span><br></pre></td></tr></table></figure></li></ul><h2 id="显示指定模板参数"><a href="#显示指定模板参数" class="headerlink" title="显示指定模板参数"></a>显示指定模板参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>, <span class="title">class</span> <span class="title">T3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T1</span> <span class="title">sum</span>(<span class="title">T2</span> <span class="title">i</span>, <span class="title">T3</span> <span class="title">j</span>)&#123;</span></span><br><span class="line">    T1 res = i + j;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数2,3能推导出来， 能省略</span></span><br><span class="line"><span class="keyword">auto</span> res = sum&lt;<span class="keyword">double</span>&gt;(<span class="number">200000000</span>, <span class="number">200000000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="title">class</span> <span class="title">T2</span>, <span class="title">class</span> <span class="title">T3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T3</span> <span class="title">sum</span>(<span class="title">T1</span> <span class="title">i</span>, <span class="title">T2</span> <span class="title">j</span>)&#123;</span></span><br><span class="line">    T3 res = i + j;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//参数不能省</span></span><br><span class="line"><span class="keyword">auto</span> res = sum&lt;<span class="keyword">double</span>, <span class="keyword">double</span>, <span class="keyword">double</span>&gt;(<span class="number">200000000</span>, <span class="number">200000000</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;函数模板&quot;&gt;&lt;a href=&quot;#函数模板&quot; class=&quot;headerlink&quot; title=&quot;函数模板&quot;&gt;&lt;/a&gt;函数模板&lt;/h2&gt;&lt;p&gt;定义模板是不会生成代码，只有当实例化时才会生成  &lt;/p&gt;
&lt;h3 id=&quot;类型模板参数
      
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="泛型" scheme="http://yoursite.com/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>patchelf</title>
    <link href="http://yoursite.com/2020/03/26/%E5%B7%A5%E5%85%B7/patchelf/"/>
    <id>http://yoursite.com/2020/03/26/%E5%B7%A5%E5%85%B7/patchelf/</id>
    <published>2020-03-26T13:09:29.000Z</published>
    <updated>2020-03-26T13:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PatchELF 是一个用来修改elf格式的动态库和可执行程序的小工具，可以修改动态链接库的库名字，以及链接库的rpath。  </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>wget <a href="https://nixos.org/releases/patchelf/patchelf-0.10/patchelf-0.10.tar.gz" target="_blank" rel="noopener">https://nixos.org/releases/patchelf/patchelf-0.10/patchelf-0.10.tar.gz</a><br>tar -zxvf patchelf-0.10.tar.gz<br>cd patchelf-0.10<br>./configure –prefix=/usr/local<br>make &amp;&amp; make install</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="修改动态库的rpath"><a href="#修改动态库的rpath" class="headerlink" title="修改动态库的rpath"></a>修改动态库的rpath</h3><p>rpath全称是run-time search path。Linux下所有elf格式的文件都包含它，特别是可执行文件。它规定了可执行文件在寻找.so文件时的第一优先位置. linux下在链接共享库的时候可以通过rpath选项来指定运行时共享库加载路径。通过这个选项指定的路径会写到ELF文件dynamic段的RPATH里, 运行时链接器会在此路径下搜索ELF文件所依赖的共享库   </p><p>编译代码时如果不指定所依赖动态库的路径很可能会编译报错<br>有如下解决方法:</p><ul><li>将所依赖的动态库路径添加到LD_LIBRARY_PATH环境变量中</li><li>链接时直接将搜索路径写到rpath中，如:<br>gcc -L. -larith main.c -Wl,-rpath=依赖动态库所在路径 -o main<br>readelf -d main | grep PATH   //查看rpath<br>如果我们拿到的时已经编译好的可执行文件，就不能像方法2一样指定rpath,<br>这时可以使用pathelf, 它可以修改elf文件，如:<br>patchelf  –set-rpath 依赖动态库路径 main 或<br>patchelf  –set-rpath ‘$ORIGIN/lib’ main //ORIGIN会在运行时解析成程序所在路径</li><li>ldd main //查看可执行程序依赖动态库</li></ul><p>–set-rpath 实际上是修改runpath, 关于rpath和runpath的区别，前者不会覆盖LD_LIBARAY_PATH, 后者会推荐使用后者</p><p>–force-rpath pathelf的默认动作是修改runpath, 如果要修改rpath就要加上该字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patchelf [--force-rpath] --set-rpath &quot;&lt;desired-rpath&gt;&quot; &lt;path-to-elf&gt;</span><br></pre></td></tr></table></figure><p><desired-path> 是用逗号分隔的目录列表，例如： /my/libs:/my/other/libs<br>如果指定–force-rpath，则设置RPATH，否则设置RUNPATH    </p><h3 id="修改动态库的名称"><a href="#修改动态库的名称" class="headerlink" title="修改动态库的名称"></a>修改动态库的名称</h3><p>如果有这样的场景: 某一个库依赖了一个第三库库的版本1，另外一个库依赖了同样的这个第三库的版本2，两个库的名字是一样的，程序运行时两个动态库都要加载，但是加载的时候由于第三库版本不一致导致程序运行过程中崩溃。这种情况下就可以通关patchelf修改其中一个的依赖库的名字，从而达到同时加载不同版本的动态库的效果，解决运行中的崩溃问题。<br>相关命令:<br>patchelf –print-needed test.so //查看依赖动态库，假设test.so依赖a.so<br>patchelf –replace-needed a.so b.so test.so //将a.so改成b.so</p><h3 id="删除rpath中未使用的路径"><a href="#删除rpath中未使用的路径" class="headerlink" title="删除rpath中未使用的路径"></a>删除rpath中未使用的路径</h3><pre><code>patchelf --shrink-rpath 可执行文件patchelf --remove-rpath &lt;path-to-elf&gt; //同时删除RPATH和RUNPATH   </code></pre><h3 id="修改动态链接器-dynamic-linker"><a href="#修改动态链接器-dynamic-linker" class="headerlink" title="修改动态链接器(dynamic linker)"></a>修改动态链接器(dynamic linker)</h3><p>在实际运行程序时，经常会遇到一个问题，电脑上安装的glibc版本不符合要求，由于glibc是最底层的库，不可能重新编译glibc，这样会导致系统崩溃。两种方法修改：<br>有代码的情况下，gcc main.c -o main - -Wl –dynamic-linker 动态链接库路径<br>二进制文件情况下，patchelf –set-interpreter 动态链接库路径 可执行文件</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>PatchELF已在i386-linux， x86_64-linux和powerpc-linux上进行了测试。它能在所有32位或64位，大端或小端   Linux平台上运行。稍作修改，它也可以在其他ELF平台上运行   </p><p>关于动态库的搜索：<br><a href="https://blog.csdn.net/FoxBryant/article/details/53389804" target="_blank" rel="noopener">https://blog.csdn.net/FoxBryant/article/details/53389804</a><br><a href="https://blog.csdn.net/dbzhang800/article/details/6918413#commentBox" target="_blank" rel="noopener">https://blog.csdn.net/dbzhang800/article/details/6918413#commentBox</a><br><a href="https://en.wikipedia.org/wiki/Rpath" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Rpath</a></p><pre><code>https://nixos.org/patchelf.html https://www.dazhuanlan.com/2019/09/24/5d89371175726/https://blog.csdn.net/force_eagle/article/details/48263365https://www.jianshu.com/p/505a32ccdc91http://shibing.github.io/2016/08/20/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8Erpath/https://blog.csdn.net/farmwang/article/details/73195799                                                                                                                     https://cqlin1995.github.io/2018/06/26/%E8%BF%90%E8%A1%8C%E4%B8%8D%E5%90%8Cglibc%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%87%E4%BB%B6/</code></pre><p>ORIGIN<br><a href="https://medium.com/@nehckl0/creating-relocatable-linux-executables-by-setting-rpath-with-origin-45de573a2e98" target="_blank" rel="noopener">https://medium.com/@nehckl0/creating-relocatable-linux-executables-by-setting-rpath-with-origin-45de573a2e98</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;PatchELF 是一个用来修改elf格式的动态库和可执行程序的小工具，可以修改动态链接库的库名字，以及
      
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>趣谈linux操作系统笔记</title>
    <link href="http://yoursite.com/2020/03/06/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/03/06/%E8%B6%A3%E8%B0%88linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-06T08:09:34.000Z</published>
    <updated>2020-03-18T08:21:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="核心原理篇"><a href="#核心原理篇" class="headerlink" title="核心原理篇"></a>核心原理篇</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><ul><li><p>操作系统内核体系结构图<br><img src="/images/linuxkernel_20200306.jpeg" alt="p1"></p></li><li><p>linux 命令图谱<br><img src="/images/linuxkernel_20200306_1.jpeg" alt="p2"></p></li><li><p>系统调用图谱<br><img src="/images/linuxkernel_20200306_2.jpeg" alt="p3"></p></li></ul><h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h3><h4 id="X86架构"><a href="#X86架构" class="headerlink" title="X86架构"></a>X86架构</h4><ul><li>计算机工作模式图<br><img src="/images/linuxkernel_20200307_1.jpeg" alt="p4">    </li></ul><ul><li>CPU组成<br>运算单元: 加法、位移<br>控制单元: CPU内部缓存和寄存器组<br>数据单元: 取指令， 根据指令取数据， 计算结果后存放数据  </li></ul><ul><li>X86架构<br><img src="/images/linuxkernel_20200307_2.jpeg" alt="p5">  </li></ul><ul><li>程序执行过程图<br><img src="/images/linuxkernel_20200308_1.jpeg" alt="p6"></li></ul><ul><li><p>总线<br>地址总线: 位数决定寻址的范围<br>数据总线: 位数决定一次能拿多少数据  </p></li><li><p>8086<br>结构图:<br><img src="/images/linuxkernel_20200308_3.jpeg" alt="p7">  </p></li></ul><p>寄存器:<br>8个16位通用寄存器，用于计算过程中暂存数据， AX、BX、CX、DX、SP、BP、SI、DI, 其中 AX、BX、CX、DX 可以分成两个 8 位的寄存器来使用，分别是 AH、AL、BH、BL、CH、CL、DH、DL<br>16位IP(Instruction Pointer Register), 指令指针寄存器，存放下一条指令在内存中的地址<br>4个16位段寄存器， CS(代码段寄存器)、DS(数据段的寄存器)、SS(栈寄存器)、ES   </p><p>实模式：<br>CS和DS中都存放这段的起始地址， IP中存放代码段偏移地址， 通用寄存器中存放数据段的偏移地址<br>8086的地址总线位20位，寻址方式：起始地址*16+偏移量， 每个段的最大寻址64k  </p><ul><li>80386<br>寄存器:<br>8个32位通用寄存器， 低16位保留了16位和八位的使用方式， 高16位没有分的原因是不兼容之前的架构(8080和8086最大寻址分别是2^16和2^20, 通用寄存器保存地址的偏移量,高16位地址已经大于2^16)<br>32位指令寄存器EIP<br>4个16位段寄存器<br><img src="/images/linuxkernel_20200308_4.jpeg" alt="p8">  </li></ul><p>保护模式：<br>段的起始地址存放在内存的某个地方，这个地方是一个表格，表格里面一项项是段描述符， 这里面才是段的起始地址， 段寄存器里面存放的是表格中的哪一项，即选择子。 CPU从段寄存器中找到表格中的选择子， 然后简介找到段起始地址， 为了更快速的拿到段起始地址， 段寄存器会从内存中拿到 CPU 的描述符高速缓存器中<br><img src="/images/linuxkernel_20200308_5.jpeg" alt="p9">  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;核心原理篇&quot;&gt;&lt;a href=&quot;#核心原理篇&quot; class=&quot;headerlink&quot; title=&quot;核心原理篇&quot;&gt;&lt;/a&gt;核心原理篇&lt;/h2&gt;&lt;h3 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综
      
    
    </summary>
    
    
      <category term="linux内核" scheme="http://yoursite.com/categories/linux%E5%86%85%E6%A0%B8/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql面试</title>
    <link href="http://yoursite.com/2020/03/03/mysql_interview/"/>
    <id>http://yoursite.com/2020/03/03/mysql_interview/</id>
    <published>2020-03-03T12:17:16.000Z</published>
    <updated>2020-07-06T23:27:01.084Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="MySQL-执行一条查询语句的内部执行过程"><a href="#MySQL-执行一条查询语句的内部执行过程" class="headerlink" title="MySQL 执行一条查询语句的内部执行过程"></a>MySQL 执行一条查询语句的内部执行过程</h3><ul><li>答案：<br>链接器=》分析器=》优化器=》执行器=》存储引擎    <ol><li>客户端先通过连接器连接到 MySQL 服务器   </li><li>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器     </li><li>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器  </li><li>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好  </li><li>优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回   </li></ol></li></ul><ul><li>详解：<br>查询、更新等语句都会走下面这个图(mysql逻辑架构图)<br><img src="/images/mysql_p1_20200304092002.png" alt="p1"><br>大体上MySQL=Server层+存储引擎层<br>Server层实现的功能：内置函数(日期、时间、数学、加密函数)和跨存储引擎功能(存储过程、触发器、视图)<br>存储引擎层功能：数据存储和提取，架构模式为插件式，最常用的存储引擎InnoDB(5.5.5后默认引擎)、MyISAM、Memory<br>连接器：<br>负责与客户端建立连接，获取权限，维持和管理连接<br>建立连接<br>mysql  -h$ip  -P$port  -u$user -p<br>获取权限<br>如果用户密码不对， 则报错”Access denied for user”， 然后退出<br>如果用户密码认证通过，连接器会到权限表里查出你拥有的权限 (即使管理员修改了你的权限也只能下次重新连接是生效)<br>管理连接<br>查询连接状态<br>show processlist<br>其中Command 为Sleep的表示空闲连接， 如果空闲时间超过wait_timeout则自动断开<br>查询缓存：<br>以key-value的形式存在内存中，key是查询命令，value是结果<br>缓存利大于弊，查询缓存失效非常频繁，只要对一个表更新，这个表上所有查询缓存都会被清空 , 更新频繁的数据库不适应缓存<br>使用场景：  业务是一张静态表，长时间不更新，例如配置信息<br>设置sql语句默认不查询<br>set session query_cache_type=DEMAND  #当前会话<br>Mysql8.0后没有查询缓存功能<br>分析器<br>优化器：<br>表里有多个索引是，决定用哪个索引，或一个语句有多表关联(join)时，决定各个表连接顺序<br>执行器：<br>先判断有没有查询权限，没有则返回错误 ， 如果有则使用引擎提供的接口      </li></ul><p>二、 MySQL执行一条更新语句内部的执行过程    </p><ul><li>答案:<br>与查询语句的流程一样：链接器=》分析器=》优化器=》执行器=》存储引擎<br>执行器和存储引擎(innodb)的细节不同：   </li></ul><ol><li>执行器先找引擎取指定主键的数据（B-,b+树）, 如果数据在内存上直接返回给执行器，否则从磁盘读入内存在返回   </li><li>执行器根据更新语句对数据进行操作后调用引擎接口写入  </li><li>引擎将这行数据更新到内存，并将更新操作记录到redo log, 此时redo log处于prepare状态，通知执行器可以提交事务。  </li><li>执行器生成这个操作的binlog, 并将binlog写入磁盘</li><li>执行器调用引擎提交事务接口，引擎讲redo log改为commit状态，更新完成      </li></ol><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="主键索引和非主键索引有什么区别（innodb引擎下）"><a href="#主键索引和非主键索引有什么区别（innodb引擎下）" class="headerlink" title="主键索引和非主键索引有什么区别（innodb引擎下）"></a>主键索引和非主键索引有什么区别（innodb引擎下）</h3><ol><li>主键索引叶子节点中存储整行数据, 非主键索引存的是主键</li><li>非主键索引可能存在回表查询， 因此IO操作可能多于主键索引, 索引应该避免回表查询   </li><li>创建方式上，如果表中有主键，会自动生成主键索引。表中无主键，将唯一索引+not null 作为主键<br>如果没有， mysql自动创建rowid, 隐式列。 非主键索引要主动创建</li><li>非主键索引会占用额外的磁盘空间，会降低更新效率   </li></ol><h3 id="为什么建议使用主键自增索引"><a href="#为什么建议使用主键自增索引" class="headerlink" title="为什么建议使用主键自增索引"></a>为什么建议使用主键自增索引</h3><p>表的存储结构， 表空间有段(索引=索引段+数据段)组成， 区=1M=64页， 1页=16k<br>不使用自增索引插入数据时B+树的结构可能也会跟着调整， 可能产生磁盘碎片降低磁盘利用率</p><h3 id="为什么索引使用整型而不是字符串"><a href="#为什么索引使用整型而不是字符串" class="headerlink" title="为什么索引使用整型而不是字符串"></a>为什么索引使用整型而不是字符串</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;h3 id=&quot;MySQL-执行一条查询语句的内部执行过程&quot;&gt;&lt;a href=&quot;#MySQL-执行一条查询语句
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql基础</title>
    <link href="http://yoursite.com/2020/02/26/mysql%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2020/02/26/mysql%E5%9F%BA%E7%A1%80/</id>
    <published>2020-02-25T23:27:19.000Z</published>
    <updated>2020-07-06T23:26:56.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><ul><li><p>创建普通索引<br>CREATE INDEX indexName ON tableName(columnName(length))</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> name_idx <span class="keyword">on</span> base(<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure><p>CREATE UNIQUE INDEX indexName ON tableName(columnName(length))   </p></li><li><p>创建唯一索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> name_idx <span class="keyword">on</span> base(<span class="keyword">name</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建复合索引<br>CREATE INDEX indexName ON tableName(columnName1, columnName2, …)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> muti_idx <span class="keyword">on</span> base(<span class="keyword">name</span>, sex, age);</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>DROP INDEX [indexName] ON tableName;  </p><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><p>SHOW INDEX FROM tableName;  </p><ul><li>使用索引分析器 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> base <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'cp'</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><ul><li>前导列特性（最左前缀）<br>在MySQL中，如果创建了复合索引(name, salary, dept)，就相当于创建了(name, salary, dept)、<br>(name, salary)和(name)三个索引，这被称为复合索引前导列特性， 因此在创建复合索引时应该将<br>最常用作查询条件的列放在最左边，依次递减</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">未使用索引</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> salary=<span class="number">8800</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> dept=<span class="string">'部门A'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> salary=<span class="number">8800</span> <span class="keyword">and</span> dept=<span class="string">'部门A'</span>;</span><br><span class="line"></span><br><span class="line">使用索引</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'liufeng'</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'liufeng'</span> <span class="keyword">and</span> salary=<span class="number">8800</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> employee <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'liufeng'</span> <span class="keyword">and</span> salary=<span class="number">8800</span> <span class="keyword">and</span> dept=<span class="string">'部门A'</span>;</span><br></pre></td></tr></table></figure><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><ul><li><p>什么是覆盖索引<br>即select的数据列只从索引中就能得到，不必读取数据行，也就是只需扫描索引就可以得到查询结果  </p></li><li><p>几点说明  </p></li></ul><ol><li>使用覆盖索引，只需要从索引中就能检索到需要的数据，而不要再扫描数据表；  </li><li>索引的体量往往要比数据表小很多，因此只读取索引速度会非常快，也会极大减少数据访问量；  </li><li>MySQL的查询优化器会在执行查询前判断，是否有一个索引可以覆盖所有的查询列；  </li><li>并非所有类型的索引都可以作为覆盖索引，覆盖索引必须要存储索引列的值。像哈希索引、空间索引、全<br>文索引等并不会真正存储索引列的值  </li><li>当一个查询使用了覆盖索引， 在查询分析器EXPLAIN的Extra列可以看到“Using index”       </li></ol><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ul><li>选择区分度高的列建立索引<br>区分度计算公式：count(distinct col)/count(*)，表示字段不重复的比例   </li><li>避免对索引列进行计算<br>from_unixtime(create_time)=’2014-05-29’ 不会用到索引   </li><li>每次查询每张表仅能使用一个索引  </li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>MyISAM 不支持， InnoDB</p></li><li><p>什么是事务<br>用来处理批量的mysql操作， 为了保证数据库的完整性，这些操作要么完全执行，要么完全不执行</p></li><li><p>几个术语<br>回退(rollback) 撤销SQL语句的过程<br>提交(commit) 未存储的SQL语句写入数据库表<br>保留点(savepoint) 事务处理中设置临时占位符(place-holder).可以发布回退 </p></li><li><p>可以执行回退的语句<br>INSERT UPDATE和DELETE</p></li><li><p>事务的4个特性(ACID)<br>原子性: 批量的sql, 要么都发生， 要么都不发生<br>一致性：事务前后的数据保持业务上的合理一致<br>持久性：事务一旦发生不能取消，只能通过补偿性事务来抵消效果<br>隔离性：在事务进行中，其他操作开不到此事务的任何效果   </p></li><li><p>操作命令<br>开启事务：start transaction<br>执行命令： xxx<br>提交事务/回滚事务 commit/rollback<br>设置隔离级别：set session transaction isolation level [read uncommitted |  read committed | repeatable read |serializable] </p></li><li><p>示例  </p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//创建表</span><br><span class="line">mysql&gt; create table account(</span><br><span class="line">    -&gt; uname char(10),</span><br><span class="line">    -&gt; money int)</span><br><span class="line">    -&gt; engine innodb charset utf8;</span><br><span class="line">//插入数据</span><br><span class="line">mysql&gt; insert into account values</span><br><span class="line">    -&gt; ('zhang', 5000),</span><br><span class="line">    -&gt; ('lisi', 3000);</span><br><span class="line"></span><br><span class="line">//开启事务</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span></span><br><span class="line"></span><br><span class="line">//更新数据</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">account</span> <span class="keyword">set</span> money = money + <span class="number">100000</span>  <span class="keyword">where</span> uname=<span class="string">'lisi'</span>;</span><br><span class="line"></span><br><span class="line">//查询</span><br><span class="line">mysql&gt; select * from account;</span><br><span class="line">+<span class="comment">-------+-------+</span></span><br><span class="line">| uname | money |</span><br><span class="line">+<span class="comment">-------+-------+</span></span><br><span class="line">| zhang |  5000 |</span><br><span class="line">| lisi  |  3000 |</span><br><span class="line"></span><br><span class="line">//设置隔离级别</span><br><span class="line">mysql&gt; set session transaction  isolation level read uncommitted</span><br><span class="line"></span><br><span class="line">//提交事务</span><br><span class="line">mysql&gt; commit;</span><br></pre></td></tr></table></figure><ul><li><p>隔离级别<br>read uncommit : “脏读”, 读到未提交事务的内容<br>read commited : 一个事务在进行的过程中， 读不到另外一个进行中事务的内容，但是能读到已经完成事务中的内容<br>repeatable read: 可重复读,即在一个事务过程中,所有信息都来自事务开始那一瞬间的信息,不受其他已提交事务的影响. (大多数的系统,用此隔离级别)<br>serializable: 串行化, 所有的事务,必须编号,按顺序一个一个来执行,也就取消了冲突的可能.这样隔离级别最高,但事务相互等待的等待长. 在实用,也不是很多 </p></li><li><p>c++中使用事务</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参考brks</span></span><br><span class="line"><span class="keyword">bool</span> MysqlConnection::transaction(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; sql)&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//手动提交</span></span><br><span class="line">mysql_autocommit(mysql_, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始事务</span></span><br><span class="line">mysql_query(mysql_, <span class="string">"start transaction"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = sql.begin(), iter != sql.end(); iter++)&#123;</span><br><span class="line">ret = mysql_qurey(mysql_, (*iter).c_ctr());</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//回滚</span></span><br><span class="line">mysqL_query(mysql_, <span class="string">"rollback"</span>);</span><br><span class="line">LOG_ERROR(<span class="string">"excute transaction failed."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> != mysql_query(mysql, <span class="string">"commit"</span>))&#123;</span><br><span class="line">LOG_ERROR(<span class="string">"commit transaction failed."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>一组为了完成特定功能的SQL语句集， 经编译后存储在数据库中， 用户通过存储过过程名并传参来调用它</p><ul><li><p>优点<br>增强的sql语音的功能和灵活性<br>存储过程允许标准组件式编程<br>较快的执行速度(存储过程是预编译的)<br>减少网络流量<br>可被作物一种安全机制充分利用   </p></li><li><p>创建步骤<br>选择一个数据库<br>改变分割符：delimiter $$(避免使用;作为结束标记)  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use test;</span><br><span class="line">mysql&gt; delimiter $$</span><br><span class="line"></span><br><span class="line">mysql&gt; create procedure p_hello()</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; select 'hello';</span><br><span class="line">    -&gt; select 'world';</span><br><span class="line">    -&gt; end</span><br><span class="line">    -&gt; $$;</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter ;</span><br><span class="line"></span><br><span class="line">mysql&gt; call p_hello;</span><br></pre></td></tr></table></figure></li><li><p>存储过程中的参数<br>in: 输入参数<br>必须在调用存储过程之前指定<br>out: 输出参数<br>可以在存储过程内部改变并返回<br>inout:输入输出参数<br>可以在调用时指定， 并可修改和返回<br>in 在存储过程中修值是传入值得一份拷贝，传入的值不会改变</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create procedure v_test1(in p_int int)</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; select p_int;</span><br><span class="line">    -&gt; set p_int = p_int +1;</span><br><span class="line">    -&gt; select p_int;</span><br><span class="line">    -&gt; end;</span><br><span class="line">    -&gt; $$;</span><br><span class="line"></span><br><span class="line">mysql&gt; delimiter </span><br><span class="line">mysql&gt; set @p_int =3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//存储过程里的值被修改</span><br><span class="line">mysql&gt; call v_test1(@p_int);</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| p_int |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     3 |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| p_int |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">|     <span class="number">4</span> |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line"></span><br><span class="line">//外面的值没变</span><br><span class="line">mysql&gt; <span class="keyword">select</span> @p_int;</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">| @p_int |</span><br><span class="line">+<span class="comment">--------+</span></span><br><span class="line">|      3 |</span><br><span class="line">+<span class="comment">--------+</span></span><br></pre></td></tr></table></figure><p>out 不认可传入的值，修改后值会变</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create procedure p_test_out(out v_out_int int)</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; select v_out_int;</span><br><span class="line">    -&gt; set v_out_int=15;</span><br><span class="line">    -&gt; select v_out_int;</span><br><span class="line">    -&gt; end</span><br><span class="line">    -&gt; $$;</span><br><span class="line"></span><br><span class="line">mysql&gt; set @v_out_int=10;</span><br><span class="line">    -&gt; $$;</span><br><span class="line">mysql&gt; call p_test_out(@v_out_int);</span><br><span class="line">    -&gt; $$;</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| v_out_int |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">|      NULL |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">| v_out_int |</span><br><span class="line">+<span class="comment">-----------+</span></span><br><span class="line">|        <span class="number">15</span> |</span><br><span class="line">+<span class="comment">-----------+</span></span><br></pre></td></tr></table></figure><p>inout 类似于引用，认可传入的值， 修改后会改变</p></li></ul><p>在存储过程里面定义变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create procedure p_vartest()</span><br><span class="line">    -&gt; begin</span><br><span class="line">    -&gt; declare a varchar(20) default 'abc';</span><br><span class="line">    -&gt; select a;</span><br><span class="line">    -&gt; end;</span><br><span class="line">    -&gt; $$;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; call p_vartest;</span><br><span class="line">    -&gt; $$;</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| a    |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">| abc  |</span><br><span class="line">+<span class="comment">------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><ul><li>c++中使用存储过程  </li><li>创建存储过程  </li><li>初始化mysql: mysql_init   </li><li>链接mysql: mysql_real_connect   </li><li>调用存储过程: mysql_real_qurey, 第二个参数，”call xxx(xxx)”</li><li>释放资源与连接：mysql_free_result， mysql_close   </li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>由查询结果形成的一张虚拟表， 如果某个查询结果出现的非常频繁， 要经常拿这个查询结果来做子查询<br>视图本身不包含数据， 它返回的数据是从其他表中检索出来的</p><ul><li>作用   </li></ul><ol><li>权限控制：如某几个列允许用户查询，其他的列不允许， 可以通过视图开放其中一列或几列           </li><li>简化复杂的查询</li></ol><ul><li><p>视图能否更新，删除，添加<br>如果视图的每一行是和物理表一一对应的才可以<br>如果view的行是由物理表多行经过计算的到的结果，view不可以更新  </p></li><li><p>视图放在哪儿（视图算法） </p></li></ul><ol><li>对于简单的查询形成的view, 再对view查询时，如where, order等， 可以把建视图的语句+查询视图的语句合并成=》查物理的语句，这种视图算法叫merge(合并)   </li><li>视图的语句本身比较复杂，很难再和查询视图的语句合并，mysql先执行视图的创建语句，把结果集形成内存中的临时表，然后再去查临时表(temptable)</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h2&gt;&lt;h3 id=&quot;创建索引&quot;&gt;&lt;a href=&quot;#创建索引&quot; class=&quot;headerlink&quot; title=&quot;创建索引&quot;&gt;&lt;/a&gt;创建索引&lt;/h
      
    
    </summary>
    
    
      <category term="中间件" scheme="http://yoursite.com/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="mysql" scheme="http://yoursite.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>cpp并发</title>
    <link href="http://yoursite.com/2020/02/20/cpp%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/02/20/cpp%E5%B9%B6%E5%8F%91/</id>
    <published>2020-02-20T14:20:11.000Z</published>
    <updated>2020-02-24T15:14:54.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="c-11中创建线程"><a href="#c-11中创建线程" class="headerlink" title="c++11中创建线程"></a>c++11中创建线程</h2><p>创建线程的几种方式</p><ul><li>使用全局函数或类静态函数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"subThread"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(threadFunc)</span></span>;</span><br></pre></td></tr></table></figure></li><li>使用函数对象<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"subThread"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Obj b;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(b)</span></span>;</span><br></pre></td></tr></table></figure></li><li>使用lambda<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> l = []&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"subThread"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(l)</span></span>;</span><br></pre></td></tr></table></figure>join<br>阻塞等待线程结束</li></ul><p>detach<br>线程分离，一般不使用此函数主进程结束即使子线程还在运行仍然会被终止，使用此函数，线程会被c＋＋运行时库接管，成为守护线程.</p><p>joinable<br>是否可以join或detach</p><h2 id="线程传参"><a href="#线程传参" class="headerlink" title="线程传参"></a>线程传参</h2><ul><li>使用detach带来的陷阱<br>线程函数中无论是引用传递还是值传递编译器都会拷贝副本，所以detach下传递int&amp;安全，传递char*不安全(主线程退出内存释放掉了)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; i, <span class="keyword">char</span>* pmybuf)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; pmybuf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> mybuf[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="function">thread <span class="title">mytobj</span><span class="params">(myprint, mvar, mybuf)</span></span>;</span><br><span class="line">mytobj.detach();</span><br></pre></td></tr></table></figure></li></ul><p>避免隐式转换<br>从char* 到 string转换时机不确定，可能主线程退出后再发生转换此时char*指向内存已销毁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i, <span class="keyword">const</span> <span class="built_in">string</span>&amp; pmybuf)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; pmybuf.c_str() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> mybuf[] = <span class="string">"hello world"</span>; </span><br><span class="line"><span class="function">thread <span class="title">mytobj</span><span class="params">(myprint, mvar, mybuf)</span></span>; <span class="comment">//改为thread mytobj(myprint, mvar, string(mybuf))可以看到内存拷贝发生在主线程退出前</span></span><br><span class="line">mytobj.detach();</span><br></pre></td></tr></table></figure><ul><li>传递类对象、智能指针、函数对象, 成员函数作为线程参数<br>线程函数传递引用类型参数前需加const<br>需要使用std::ref才能传递myobj的引用 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    A(<span class="keyword">int</span> a) : m_i(a)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"A()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a):m_i(a.m_i)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; A(constA&amp; ) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~A()&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"~A()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="keyword">const</span> A&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; a.m_i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//thread mytobj(myprint, myobj); </span></span><br><span class="line"><span class="function">thread <span class="title">mytobj</span><span class="params">(myprint, <span class="built_in">std</span>::ref(myobj))</span></span>; </span><br><span class="line">mytobj.join();</span><br></pre></td></tr></table></figure></li></ul><p>传递std::unique_ptr使用std::move</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myprint</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pzn)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; p(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>));</span><br><span class="line"><span class="comment">//thread mytobj(myprint, myobj); 这样操作有问题unique_ptr是独占指针 </span></span><br><span class="line"><span class="function">thread <span class="title">mytobj</span><span class="params">(myprint, <span class="built_in">std</span>::move(myobj))</span></span>; </span><br><span class="line">mytobj.join();</span><br></pre></td></tr></table></figure><p>函数对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">mytobj</span><span class="params">(myobj, <span class="number">15</span>)</span></span>; <span class="comment">//会有拷贝构造</span></span><br><span class="line"><span class="function">thread <span class="title">mytobj</span><span class="params">(<span class="built_in">std</span>::ref(myobj), <span class="number">15</span>)</span></span>; <span class="comment">//没有拷贝构造</span></span><br><span class="line">mytobj.join();</span><br></pre></td></tr></table></figure><p>用成员函数指针做线程函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="keyword">int</span> m_i;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">thread_work</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">" "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">myobj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">thread <span class="title">mytobj</span><span class="params">(&amp;A::thread_work, myobj, <span class="number">15</span>)</span></span>; <span class="comment">//会有拷贝构造</span></span><br><span class="line"><span class="comment">// thread mytobj(&amp;A::thread_work, std::ref(myobj), 15); //没有拷贝构造</span></span><br><span class="line"><span class="comment">// thread mytobj(&amp;A::thread_work, &amp;myobj, 15); //没有拷贝构造</span></span><br><span class="line">mytobj.join();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;c-11中创建线程&quot;&gt;&lt;a href=&quot;#c-11中创建线程&quot; class=&quot;headerlink&quot; title=&quot;c++11中创建线程&quot;&gt;&lt;/a&gt;c++11中创建线程&lt;/h2&gt;&lt;p&gt;创建线程的几种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>《Linux内核完全注释》笔记</title>
    <link href="http://yoursite.com/2020/02/18/linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/"/>
    <id>http://yoursite.com/2020/02/18/linux%E5%86%85%E6%A0%B8%E5%AE%8C%E5%85%A8%E6%B3%A8%E9%87%8A/</id>
    <published>2020-02-18T11:46:41.000Z</published>
    <updated>2020-03-30T01:04:56.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>  <h2 id="第二章-Linux内核体系结构"><a href="#第二章-Linux内核体系结构" class="headerlink" title="第二章 Linux内核体系结构"></a>第二章 Linux内核体系结构</h2><h3 id="Linux内核模式"><a href="#Linux内核模式" class="headerlink" title="Linux内核模式"></a>Linux内核模式</h3><p>操作系统体系结构模式主要分为：<br>整体式单内核(宏内核)<br>层次式微内核  </p><p>单核模式内核层次:<br>调用服务的主程序层<br>执行系统调用的服务层<br>支持系统调用的底层函数<br><img src="/images/66dc1980-6148-4883-aa5b-695b3a9e0817.png" alt="p1">  </p><h3 id="Linux内核系统体系结构"><a href="#Linux内核系统体系结构" class="headerlink" title="Linux内核系统体系结构"></a>Linux内核系统体系结构</h3><p>Linux内核主要由5个模块构成：进程调度模块，内存管理模块，文件系统模块，进程间通信模块，网络接口模块<br>模块间的依赖关系:<br><img src="/images/fc77df7e-b967-4408-934b-ba46535033e2.png" alt="p2">  </p><p>Linux 0.11架构图:<br><img src="/images/00367ae6-72cc-4b02-9f9e-4ecefac7afce.png" alt="p3">  </p><h3 id="Linux进程控制"><a href="#Linux进程控制" class="headerlink" title="Linux进程控制"></a>Linux进程控制</h3><p>内核态程序是不可抢占的(不会被schedule切换)， 用户态程序可以被抢占<br>一个进程可以在内核态或用户态下执行，内核堆栈和用户堆栈是分开的  </p><h4 id="任务数据结构"><a href="#任务数据结构" class="headerlink" title="任务数据结构"></a>任务数据结构</h4><p>进程上下文：当一个进程在执行时， CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。<br>睡眠等待状态被分为可中断和不可中断  </p><h4 id="进程五种运行状态"><a href="#进程五种运行状态" class="headerlink" title="进程五种运行状态"></a>进程五种运行状态</h4><p>运行状态：进程正在被CPU执行，或者准备就绪随时可由调度程序执行<br>可中断睡眠状态：当系统产生中断或释放进程正在等待的资源或进程收到一个型号，进程能被唤醒转换到就绪状态<br>不可中断睡眠状态：只有被使用wake_up()明确唤醒时才能转换到可运行的就绪状态<br>暂停状态：当进程收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU进入暂停状态，像其发送SIGCONT转换到可运行状态<br>僵死状态：进程已停止运行，但父进程还没有询问其状态<br>进程状态及转换关系：<br><img src="/images/70009bcf-eeea-4c5d-a784-fa561271b33e.png" alt="p4"><br>进程调度发生的情况:<br>进程时间片用完<br>进程自动放弃CPU使用权    </p><p>内核态时进程不能被 抢占，内核执行临界区代码时禁止一切中断  </p><h4 id="进程初始化"><a href="#进程初始化" class="headerlink" title="进程初始化"></a>进程初始化</h4><p>sched_init()：<br>设置任务0运行环境变量<br>预先设置好任务0数据结构个字段<br>在全局描述符表中添加任务0的TTS(任务状态段)描述符和LDT(局部描述符表)的段描述符，并把他们分别加载到tr(任务寄存器)和(ldr)局部描述符表寄存器  </p><p>move_to_user_mod()：<br>把运行特权级从内核态0级变换到用户态3级, 但是任然继续执行原来的代码.  </p><h4 id="创建新进程"><a href="#创建新进程" class="headerlink" title="创建新进程"></a>创建新进程</h4><p>过程：<br>使用fork创建，所有金产能都是通过复制进程0得到， 都是进程0的子进程<br>申请内存<br>复制当前进程数据结构<br>清除信号位图<br>设置时间片<br>设置tss中各寄存器的值  </p><h4 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h4><p>被抢占的进程仍处于TASK_RUNNING, 但是没被cpu执行，抢占发生在用户态，内核态不能被抢占，Linux 0.11 采用优先级排队调度策略<br>schedule 首先在TASK_RUNNING进程中选，谁counter值最大执行谁 如   果这些进程时间片都用完就根据优先权值priority重新分配时间片公式：<br><img src="/images/a0bcedee-f079-4dd0-9643-99de53b48236.png" alt="p5"><br> 如果此时没有其他进程运行，系统就会选择0号进程  </p><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>switch_to():<br>如果切换的就是当前进程则什么也不做， 否则ljmp新进程的tss地址处， cpu各寄存器状态会保存到原来进程的tss， 然后将新进程的tss寄存器信息恢复到cpu中  </p><p>任务切换操作示意图:<br><img src="/images/e0273d2a-56b1-4bea-acc9-bacf3d03238a.png" alt="p6">  </p><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>流程:<br>用户程序调用exit, 内核执行do_exit<br>关闭进程会释放内存，关闭进程打开着的所有文件<br>如果有子进程，让init进出给你作为紫金城的父进程<br>如果进程是会话头进程且控制终端，则释放子进程，并向会话所有进程发送SIGHUP<br>将进程状态至为TASK_ZOMBIE, 并向原父进程发送SIGCHLD<br>调用do_exit  </p><p>进程终止时，其数据结构还保留，因为父进程要用到<br>父进程使用wait或waitpid等待子进程终止  </p><h3 id="Linux内核对内存的使用方法"><a href="#Linux内核对内存的使用方法" class="headerlink" title="Linux内核对内存的使用方法"></a>Linux内核对内存的使用方法</h3><p>Linux 0.11内核物理内存分布：<br><img src="/images/p1_20200224112830.png" alt="p6">  </p><p>Intel CPU两种内存管理系统：内存分段，分页<br>三种地址<br>进程的逻辑地址: 程序产生与段相关的偏移地址<br>CPU的线性地址: 逻辑地址 + 基地址<br>实际物理内存地址: CPU外部地址总线上的寻址物理内存的地址信号<br>如果启用了分页机制，线性地址会使用页目录和页表中的项变换成物理地址，如果没有启用线性地址直接成为物理地址</p><p>分页机制应用：建立一个大而连续的内存空间映像</p><p>虚拟内存，是一种利用二级或外部存储空间，使程序不受物理内存限制的方法，通常要大于物理内存</p><p>虚拟内存实现：<br>程序申请一段内存，如果内存页表中相应页面不存在内存中，CPU产生一个缺页中断，并把引起中断的线性地址放到CR2控制寄存器中， 中断处理程序通过地址把页面从二级存储空间（如硬盘）加载到物理内存， 如果内存已占满，则借助二级存储空间一部分作为交换缓冲区（Swapper）把内存中暂时不用的页面交换到二级缓冲区中，然后吧要求的页面调入内存。</p><p>内存映射<br>虚拟内存通过局部段描述符表(LDT)变换为CPU整个线性地址空间中的地址，再使用也目录表PDT(一级页表)和页表PT(二级页表)映射到物理地址页.</p><h3 id="Linux系统中堆栈的使用方法"><a href="#Linux系统中堆栈的使用方法" class="headerlink" title="Linux系统中堆栈的使用方法"></a>Linux系统中堆栈的使用方法</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;  
&lt;h2 id=&quot;第二章-Linux内核体系结构&quot;&gt;&lt;a href=&quot;#第二章-Linux内核体系结构&quot; class=&quot;headerlink&quot; title=&quot;第二章 Linux内核体系结构&quot;&gt;&lt;/a&gt;第二章 Linux内核体系结构&lt;/h2&gt;&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>tcp-ip面试</title>
    <link href="http://yoursite.com/2020/02/16/%E9%9D%A2%E8%AF%95/tcp-ip%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2020/02/16/%E9%9D%A2%E8%AF%95/tcp-ip%E9%9D%A2%E8%AF%95/</id>
    <published>2020-02-16T05:31:11.000Z</published>
    <updated>2020-03-03T12:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>tcp连接是永久的只要没断开<br>tcp连接是指tcp协议栈维护的状态<br>tcp 流式协议，数据是有序的。面向连接可靠，慢，开销大，容易受攻击<br>udp 数据报协议，数据不保证有序。不需要连接， 不可靠，快，开销小</p><a id="more"></a>  <h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p>三次握手：<br> &nbsp;&nbsp;&nbsp;1.客户端发起连接请求，SYN=1，seq=y, 客户端进入SYN_SENT状态<br> &nbsp;&nbsp;&nbsp;2.服务端收到连接，SYN=1,ack=y+1, seq=q, 服务端进入SYN_RCVD状态<br> &nbsp;&nbsp;&nbsp;3.客户端收到服务端的回应, ACK=1，ack=q+1, 客户端进入ESTABLISHED，服务端收到后也进入ESTABLISHED   </p><p>四次挥手：<br> &nbsp;&nbsp;&nbsp;&nbsp;主动关闭：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.主动关闭方close FIN=1, 进入FIN_WAIT_1状态<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.被动关闭方收到请求, 发送 ACK=1确认后进入CLOSE_WAIT状态，主动关闭方收到后进入FIN_WAIT_2<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.被动关闭close 发送FIN=1, 进入LAST_ACK状态<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.主动关闭方收到后，发送ACK=1，进入TIME_WAIT状态<br> &nbsp;&nbsp;&nbsp;&nbsp;同时关闭：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双方发送ACK后进入CLOSING，不会有FIN_WAIT_2,LAST_ACK, CLOSEWAIT    </p><p>序号：<br> &nbsp;&nbsp;&nbsp;每个字节的数据都有自己的序号，对端接收的数据是乱序时用来确定顺序  </p><p>ISN:<br> &nbsp;&nbsp;&nbsp;三次握手第一个连接时的序列号     </p><p>判断syn flood攻击：  </p><pre><code>netstat -nap | grep SYN_RECV        </code></pre><p>防止Syn Flood方法：<br> &nbsp;&nbsp;&nbsp;1.清除所有的半连接<br> &nbsp;&nbsp;&nbsp;2.syn cookie(sysctl.conf tcp_syncookies选项)  </p><p>半关闭状态：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主动关闭端发送FIN，被动关闭端回ACK后  </p><p>三次握手中握手包丢了会怎么样<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第三次握手中丢包，服务端会有一个定时器，负责重发，会重发5次，第一次1s，以后时间在上次基础上翻倍，如果客户端还是回ack服务端会发rst  </p><h2 id="三次握手，四次挥手的原因"><a href="#三次握手，四次挥手的原因" class="headerlink" title="三次握手，四次挥手的原因"></a>三次握手，四次挥手的原因</h2><p>三次握手:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.服务端的seq(序号)和ack(确认号)是一起发给客户端的<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.客户端如果不发ack包， 服务端一直会超时重传（防止syn flood攻击）<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.三次握手的本质是为了确认连接双方的初始序列号<br>四次挥手：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.ACK 和 FIN 是分开的<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.TCP是全双工协议，一端可读可写，半关闭只关闭了写端，还可以读数据  </p><h2 id="TIME-WAIT状态是什么，为什么会有，那一方会有"><a href="#TIME-WAIT状态是什么，为什么会有，那一方会有" class="headerlink" title="TIME_WAIT状态是什么，为什么会有，那一方会有"></a>TIME_WAIT状态是什么，为什么会有，那一方会有</h2><p>time_wait:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主动关闭的一端发出ACK包后进入的状态，等待2MSL时间后进入CLOSE状态<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主动发送 RST段的一方，不会进入TIME_WAIT 状态<br>原因:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.保证TCP全双工通信可靠性<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有TIME_WAIT，对端没收到ACK包会重发FIN包，在2MSL内会重发ACK包<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有TIME_WAIT，主动关闭方直接进入CLOSE状态，收到FIN包时会返回RST错误(ECONNRESET)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果主动关闭方挂掉，对端会一直重发FIN，知道重置连接<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 保证建立新连接时，旧连接重传的包在网络中小时而不影响新连接<br>TIME_WAIT引发的问题:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.进程退出后，端口不能再次绑定(解决:SO_REUSEADDR)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.出现大量的TIME_WAIT<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般在高并发短连接，服务器主动关闭socket, 出现大量TIME_WAIT，导致部分用户连不上<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决办法：修改内核相关参数(/etc/sysctl.conf, 重用与快速回收)       </p><h2 id="TCP相关操作"><a href="#TCP相关操作" class="headerlink" title="TCP相关操作"></a>TCP相关操作</h2><p>查看系统支持端口号范围：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cat /proc/sys/net/ipv4/ip_local_port_range<br>扩大可用端口范围:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 15000 65000 &gt; /proc/sys/net/ipv4/ip_local_port_range<br>查看tcp连接默认的timeout时长:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cat /proc/sys/net/ipv4/tcp_fin_timeout<br>缩短timeout的时间:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout<br>统计tcp各个状态数:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;netstat -ant|awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}’<br>知名服务器端口定义：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/etc/services  </p><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p>固定20 + 可选项40 = 最大60<br>mss在可选项中<br>mss和MTU：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mss: 最大报文段长度，tcp能发的数据长度，只在三次握手的第一次握手发送给对端（一般1460）<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mtu: 最大传输单元， 网卡一次发送数据的大小（一般是1500）<br>修改mss iptable<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看mtu netstat -i<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改mtu vim /etc/network/interfaces /etc/init.d/networking restart<br>PUSH:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发送方最后发送的TCP段将会被标记为push<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接收方收到push标志到段，将接收缓冲区的内容拷贝到应用进程  </p><p>URG与紧急指针:<br>紧急指针只在URG=1的时候有用<br>紧急指针实际是序列号的偏移量<br>TCP只支持一个字节的紧急数据<br>紧急数据及linux中的带外数据（MSG_OOB）<br>可以在select设置exceptfds，在epoll中EPOLLPRI监听<br>seq:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决乱序<br>ack:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决丢包<br>window:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;流控<br>tcpflag:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tcp状态机<br>tcp头中的窗口是指真个滑动窗口大小吗？  </p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>延时ack：<br> &nbsp;&nbsp;&nbsp;接收数据的一方会根据需要延时发送ack(linux 中动态调节算法在快速ack和延时ack中切换)<br> &nbsp;&nbsp;&nbsp;一般情况下：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.当接收方有数据发送，ack会和数据一起发送<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.如果没有数据会延时200ms，在这期间有数据会和数据一起发送，如果过了时间没有数据，ack会被发送<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.如果延时期间又有第二个数据到来会立即发送ack<br> &nbsp;&nbsp;&nbsp;优点：减少了发送的分段，提高了网络利用率，节省带宽<br> &nbsp;&nbsp;&nbsp;缺点：增大网络延迟<br> &nbsp;&nbsp;&nbsp;关闭延时发送：TCP_QUICKACK<br> &nbsp;&nbsp;&nbsp;注意：每次recv后要重新设置<br>nagle算法:<br> &nbsp;&nbsp;&nbsp;发送数据的一方会累积数据直到接收方发来ack包后才将数据一起发送出去（最多累积到一个mss的大小），为了尽可能的发送大块数据<br> &nbsp;&nbsp;&nbsp;优点：提高了吞吐量<br> &nbsp;&nbsp;&nbsp;缺点：增大网络延时<br> &nbsp;&nbsp;&nbsp;nagle和延时确认都是为了减少小包   </p><p>滑动窗口:<br> &nbsp;&nbsp;&nbsp;目的为了做流量控制，防止对方发送过快导致缓冲区被塞满, 在tcp头的窗口字段确定其大小<br> &nbsp;&nbsp;&nbsp;持续定时器：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当对端窗口为0是，为防止本端死等，会定时发送长度为1的探测报文段（时间层指数增长）<br> &nbsp;&nbsp;&nbsp;问题：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;糊涂窗口综合征：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滑动窗口变小导致发送的数据量表小，久之导致网络传输效率变低<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方法:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nagle算法<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clark算法和延时ACK  </p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>网络拥塞:<br> &nbsp;&nbsp;&nbsp;路由器等网络设备来不及处理高数率到来的流量出现的丢包现象<br> &nbsp;&nbsp;&nbsp;判断：1.ack超时 2.连续收到同样的ack  </p><p>慢启动：<br> &nbsp;&nbsp;&nbsp;tcp会将大的数据分成若干小的分组，分为若干次发送，而不是一次全部发出去<br> &nbsp;&nbsp;&nbsp;cwdn按照两倍大小增加，大于慢启动门限是进入拥塞避免算法（指数增长）<br> &nbsp;&nbsp;&nbsp;拥塞窗口（cwdn）<br> &nbsp;&nbsp;&nbsp;慢启动门限（ssthresh）  </p><p>拥塞避免算法<br> &nbsp;&nbsp;&nbsp;cwdn 每次大小加1（线性增长）, 出现拥塞时cwdn和ssthresh被重置（一般ssthresh=cwdn/2, cwdn=1）， 然后进入慢启动算法<br> &nbsp;&nbsp;&nbsp;加法增大，乘法减小  </p><p>快重传：<br> &nbsp;&nbsp;&nbsp;接收方收到一个失序的报文段， 会不断重发相同的ACK（没收到包的序号）<br> &nbsp;&nbsp;&nbsp;发送方连续收到三个相同的Ack, 会立即发送对方Ack的包<br> &nbsp;&nbsp;&nbsp;解决了超时的问题， 但是没有解决重传哪些包的问题（需要sack算法）                            </p><p>快恢复：<br> &nbsp;&nbsp;&nbsp;出现超时重传或快重传（连续三个重复的ACK包)时:<br> &nbsp;&nbsp;&nbsp;ssthresh &nbsp;= cwdn/2<br> &nbsp;&nbsp;&nbsp;cwdn = ssthresh  </p><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>快速重传与超时重传<br>超时重传:<br> &nbsp;&nbsp;&nbsp;RTO:(超时重传时间，发送方发出一个包，会启动定时器，定时器超时未收到包，则会重发，这个时间成为重传超时)， 由RTT（数据往返时间）根据公式计算出<br> &nbsp;&nbsp;&nbsp;RTO时间指数方式增加<br> &nbsp;&nbsp;&nbsp;定时器超时后，在滑动窗口内没有收到ACK的包都会重传（sack算法）<br>设置重发次数：<br> &nbsp;&nbsp;&nbsp;/proc/sys/net/ipv4/tcp_retries1<br> &nbsp;&nbsp;&nbsp;/proc/sys/net/ipv4/tcp_retries2  </p><h2 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h2><p>保活定时器<br>服务端探测死连机制（探测客户端宕机或重启, &nbsp;如果是主动关闭连接）<br>缺点：无法识别客户端宕机和还是报文不可达<br>设置：SO_KEEPALIVE  </p><h2 id="数据在不同层的叫法"><a href="#数据在不同层的叫法" class="headerlink" title="数据在不同层的叫法"></a>数据在不同层的叫法</h2><p>数据链路层 帧<br>网络层 包（tcp）, 报（udp）<br>传输层 段  </p><h2 id="arp是什么，实现，怎么找到MAC-arp欺骗"><a href="#arp是什么，实现，怎么找到MAC-arp欺骗" class="headerlink" title="arp是什么，实现，怎么找到MAC, arp欺骗"></a>arp是什么，实现，怎么找到MAC, arp欺骗</h2><p>利用arp缓存中ip与mac的映射，如果有对方mac可以直接通信，没有发给rap广播， 当对方收到后会将自己的MAC填到包里面返回<br>同时将发送方的ip和mac映射放在arp缓存中<br>arp欺骗: 主要方式是中间人攻击，达到获取通信双方数据又不被发现的效果<br>预防：使用arp网关  </p><h2 id="TCP粘包处理"><a href="#TCP粘包处理" class="headerlink" title="TCP粘包处理"></a>TCP粘包处理</h2><p>利用包体长度，bodylen<br> &nbsp;&nbsp;&nbsp;1. 如果缓冲区里面的消息长度小于消息头长度，不处理<br> &nbsp;&nbsp;&nbsp;2. 如果缓冲区长度大于等于bodylen + headlen, 处理  </p><h2 id="HTTP-请求的过程"><a href="#HTTP-请求的过程" class="headerlink" title="HTTP 请求的过程"></a>HTTP 请求的过程</h2><p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接  </p><p>参考：<br><a href="https://blog.csdn.net/dog250/article/details/13760985" target="_blank" rel="noopener">TCP的TIME_WAIT快速回收与重用</a><br><a href="https://www.cnblogs.com/dadonggg/p/8778318.html" target="_blank" rel="noopener">解决TIME_WAIT过多造成的问题</a><br><a href="https://elf8848.iteye.com/blog/1739571" target="_blank" rel="noopener">TCP/IP TIME_WAIT状态原理</a><br><a href="https://blog.csdn.net/wuji0447/article/details/78356875" target="_blank" rel="noopener">tcp状态介绍最详细–没有之一</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666543559&idx=1&sn=83cf0e9367511d6b311909a5b3dfc81e&chksm=80dcfd6cb7ab747af19259cce70621b269c5fae25582af7c57f5be904bc18e216625cf6f4157&mpshare=1&scene=24&srcid=0110n9eggIf8eEIoZnl2Loe5&key=02793bf78abe30c4c571e7a6695d4645e0c3637a779c7915ba755677395083d39ee60f9a9d204e28b6d06d279fff9d0a25171eac0cb3e8f126cf46a027d6459f015c13308729af2f9d27c88c38e270c4&ascene=14&uin=ODI0NTI3MTg0&devicetype=Windows+7&version=62060728&lang=zh_CN&pass_ticket=wXb/sgBYyv1S7izs0CuJXuDgNxtBHPyjdhjnyZMw7twBDQnbBA0IyQV1EnfMvwsI" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗？</a><br><a href="https://blog.csdn.net/wdscq1234/article/details/52430382" target="_blank" rel="noopener">TCP-IP详解：Delay ACK</a><br><a href="https://my.oschina.net/xinxingegeya/blog/485643" target="_blank" rel="noopener">TCP Nagle算法&amp;&amp;延迟确认机制</a><br><a href="https://blog.csdn.net/ce123_zhouwei/article/details/9050797" target="_blank" rel="noopener">TCP中的Nagle算法</a><br><a href="https://blog.csdn.net/wdscq1234/article/details/52444277" target="_blank" rel="noopener">TCP-IP详解：滑动窗口（Sliding Window)</a><br><a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">TCP协议的滑动窗口具体是怎样控制流量的</a><br><a href="https://blog.csdn.net/ordeder/article/details/43243425" target="_blank" rel="noopener">TCP带外数据（URG，MSG_OOB</a><br><a href="https://blog.csdn.net/gbasp2008/article/details/47666421" target="_blank" rel="noopener">带外数据和TCP紧急指针</a><br><a href="https://blog.csdn.net/u012122743/article/details/46484675" target="_blank" rel="noopener">TCP紧急数据</a><br><a href="https://blog.csdn.net/wdscq1234/article/details/52476231" target="_blank" rel="noopener">TCP-IP详解：超时重传机制</a><br><a href="https://blog.csdn.net/wdscq1234/article/details/52503315" target="_blank" rel="noopener">TCP-IP详解：SACK选项（Selective Acknowledgment）</a><br><a href="https://blog.csdn.net/q1007729991/article/details/70185266" target="_blank" rel="noopener">27-TCP 协议（快重传与快恢复）</a><br><a href="https://perthcharles.github.io/2015/09/07/wiki-tcp-retries/" target="_blank" rel="noopener">聊一聊重传次数</a><br><a href="http://www.orczhou.com/index.php/2011/10/tcpip-protocol-start-rto/" target="_blank" rel="noopener">TCP/IP重传超时–RTO</a><br><a href="https://blog.csdn.net/q1007729991/article/details/69091877" target="_blank" rel="noopener">0-Linux 网络编程修炼指南——内功心法</a><br><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a><br><a href="https://zhuanlan.zhihu.com/p/25569676" target="_blank" rel="noopener">从TCP三次握手说起–浅析TCP协议中的疑难杂症（1)</a><br><a href="https://zhuanlan.zhihu.com/p/25596865" target="_blank" rel="noopener">从TCP三次握手说起–浅析TCP协议中的疑难杂症（2）</a><br><a href="http://netsecurity.51cto.com/art/201303/386031.htm" target="_blank" rel="noopener">中间人攻击——ARP欺骗的原理、实战及防御</a><br><a href="https://blog.csdn.net/qq_37969433/article/details/79587026" target="_blank" rel="noopener">ARP欺骗的两种方式</a><br><a href="https://blog.csdn.net/Mary19920410/article/details/72857764" target="_blank" rel="noopener">浅析TCP之头部可选项</a><br><a href="https://blog.csdn.net/mary19920410/article/details/58030147" target="_blank" rel="noopener">TCP报文格式详解</a><br><a href="https://www.cnblogs.com/xiaomayizoe/p/5258754.html" target="_blank" rel="noopener">TCP和UDP的优缺点及区别</a><br><a href="https://blog.csdn.net/freeelinux/article/details/53823731" target="_blank" rel="noopener">muduo库chat server对TCP粘包问题的处理</a><br><a href="https://blog.csdn.net/yusiguyuan/article/details/17270679" target="_blank" rel="noopener">TCP分包方法 &amp;&amp; 粘包处理策略</a><br><a href="https://blog.csdn.net/lu_embedded/article/details/77430050" target="_blank" rel="noopener">Linux 网络编程——TCP 粘包及其解决方案</a><br><a href="https://juejin.im/post/5a8102e0f265da4e710f5910" target="_blank" rel="noopener">HTTP面试题都在这里</a><br><a href="https://www.zhihu.com/question/23202402" target="_blank" rel="noopener">HTTP是一个无状态的协议。这句话里的无状态是什么意思</a><br><a href="https://www.zhihu.com/question/24938934" target="_blank" rel="noopener">服务端是如何主动推送信息到客户端的？</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIwNTc3OTAxOA==&mid=2247484323&idx=1&sn=5513334623b73352034a828badfe985d&chksm=972afa86a05d7390fe96222718fd9ce6c21fe700af7e7f9396449815a5323e7315d96681bcac&scene=0&xtrack=1&key=a539a6045067ac190e5c71cc4876a35ec2cab39ecc57c3618a3c22861a71c8bfa13cb8c4e1190e7ca56b6fa54c00b894874dabfdb24eb7aa3f45382bd07dd271a25982549dfd70f959b71db7aeb5d371&ascene=14&uin=ODI0NTI3MTg0&devicetype=Windows+7&version=62060739&lang=zh_CN&pass_ticket=UG6jIZiPy0h82EWKj8fu5ZN0dIyjwygUpMCiLLSskgXdEE9mhfeXBtYPbOR2lLEE" target="_blank" rel="noopener">程序员过关斩将–面试官再问你Http请求过程，怼回去！</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP和UDP的区别&quot;&gt;&lt;a href=&quot;#TCP和UDP的区别&quot; class=&quot;headerlink&quot; title=&quot;TCP和UDP的区别&quot;&gt;&lt;/a&gt;TCP和UDP的区别&lt;/h2&gt;&lt;p&gt;tcp连接是永久的只要没断开&lt;br&gt;tcp连接是指tcp协议栈维护的状态&lt;br&gt;tcp 流式协议，数据是有序的。面向连接可靠，慢，开销大，容易受攻击&lt;br&gt;udp 数据报协议，数据不保证有序。不需要连接， 不可靠，快，开销小&lt;/p&gt;
    
    </summary>
    
    
      <category term="协议" scheme="http://yoursite.com/categories/%E5%8D%8F%E8%AE%AE/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>cpp细节</title>
    <link href="http://yoursite.com/2020/01/08/cpp/cpp%E7%BB%86%E8%8A%82/"/>
    <id>http://yoursite.com/2020/01/08/cpp/cpp%E7%BB%86%E8%8A%82/</id>
    <published>2020-01-08T11:59:12.000Z</published>
    <updated>2020-02-16T05:52:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动构造函数中如果有拷贝动态内存要注意将指针赋空"><a href="#移动构造函数中如果有拷贝动态内存要注意将指针赋空" class="headerlink" title="移动构造函数中如果有拷贝动态内存要注意将指针赋空"></a>移动构造函数中如果有拷贝动态内存要注意将指针赋空</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : m_ptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) : m_ptr(a.m_ptr)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    A(A&amp;&amp; a) : m_ptr(a.m_ptr)&#123;a.m_ptr = <span class="literal">nullptr</span>; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~A()&#123;<span class="keyword">delete</span> m_ptr; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destruct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="重载决议"><a href="#重载决议" class="headerlink" title="重载决议"></a>重载决议</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a_;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">foo(T&amp;&amp; v) : a_&#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(v)&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="keyword">const</span> foo&amp; rhs) : a_&#123;rhs.a_&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="built_in">std</span>::<span class="keyword">uint8_t</span>()&#123;<span class="keyword">return</span> a_;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo bar1&#123;<span class="number">256</span>&#125;, bar2&#123;bar1&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bar1.a_ == bar2.a_)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，编译器会选择会选择移动构造函数而不是拷贝构造，应为如果调用拷贝构造bar1会存在隐式转换.但是如果是默认的拷贝构造则会优先被调用<br><a href="https://stackoverflow.com/questions/53902448/template-constructor-and-copy-constructor" target="_blank" rel="noopener">Template constructor and copy constructor</a></p><h2 id="vector删除性能对比"><a href="#vector删除性能对比" class="headerlink" title="vector删除性能对比"></a>vector删除性能对比</h2><p><a href="https://sourcegraph.com/github.com/colinblack/language/-/blob/c++/stl/vector/vector_pop_back.cc#L14" target="_blank" rel="noopener">vector_pop_back.cc</a></p><h2 id="vector-构造函数"><a href="#vector-构造函数" class="headerlink" title="vector 构造函数"></a>vector 构造函数</h2><p>vector<inv> v(10)　构造一个size(不是capacity)为10的vector</p><h2 id="关联容器的构造函数"><a href="#关联容器的构造函数" class="headerlink" title="关联容器的构造函数"></a>关联容器的构造函数</h2><p>如map set unordered_map 中 使用[]操作符，首先会调无参构造函数，插入元素正确的方式是使用insert, 但是这会调用两次拷贝构造，需使用std::move。使用[]操作符复制是调用的是拷贝操作符，使用insert会调拷贝构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Item(<span class="keyword">int</span> a): i(a)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">    <span class="keyword">int</span> b_;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Item&gt; v_;</span><br><span class="line">    Demo()</span><br><span class="line">    &#123;</span><br><span class="line">        a_ = <span class="number">0</span>;    </span><br><span class="line">        b_ = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no param "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Demo(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="built_in">vector</span>&lt;Item&gt;&amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        a_ = a;    </span><br><span class="line">        b_ = b;</span><br><span class="line">        v_ = v;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"param "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Demo(<span class="keyword">const</span> Demo&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        a_ = obj.a_;    </span><br><span class="line">        b_ = obj.b_;</span><br><span class="line">        v_ = <span class="built_in">std</span>::move(obj.v_);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Demo&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Demo&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        a_ = obj.a_;</span><br><span class="line">        b_ = obj.b_;</span><br><span class="line">        v_ = <span class="built_in">std</span>::move(obj.v_);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy operator "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Item&gt; v;</span><br><span class="line">    v.push_back(Item(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">unsigned</span>, Demo&gt; m;</span><br><span class="line">    m.insert(&#123;<span class="number">1</span>, Demo(<span class="number">1</span>, <span class="number">2</span>, v)&#125;);</span><br><span class="line">    m[<span class="number">1</span>] = Demo(<span class="number">1</span>, <span class="number">2</span>, v);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m[<span class="number">1</span>].a_ &lt;&lt; <span class="string">" "</span> &lt;&lt; m[<span class="number">1</span>].b_ &lt;&lt; <span class="string">" "</span> &lt;&lt; m[<span class="number">1</span>].v_.size() &lt;&lt; <span class="string">" "</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C中的结构体"><a href="#C中的结构体" class="headerlink" title="C中的结构体"></a>C中的结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd_set rd;</span><br><span class="line">fd_set all;</span><br><span class="line">ll = rd; <span class="comment">//合法</span></span><br><span class="line">fd_set 是个结构体, 里面有一个整型数组， c++中则会调用拷贝操作符</span><br></pre></td></tr></table></figure><h2 id="STL-中的类型"><a href="#STL-中的类型" class="headerlink" title="STL 中的类型"></a>STL 中的类型</h2><p>SIZE_TYPE：不同平台下长度不一样， 64位下是8字节，unsigned log<br><img src="/images/f1a84799-5f3b-41a6-a52d-d75a92fdea4d.png" alt="size_type"></p><p>这里返回值不能用unsigned去接， 否则找不到会返回-1, 实际find找不到只会返回sting::npos, 显然是类型溢出</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;移动构造函数中如果有拷贝动态内存要注意将指针赋空&quot;&gt;&lt;a href=&quot;#移动构造函数中如果有拷贝动态内存要注意将指针赋空&quot; class=&quot;headerlink&quot; title=&quot;移动构造函数中如果有拷贝动态内存要注意将指针赋空&quot;&gt;&lt;/a&gt;移动构造函数中如果有拷贝动态内存要注意将指针赋空&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A() : m_ptr(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&amp;#123;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;construct&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; a) : m_ptr(a.m_ptr)&amp;#123;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;copy construct&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A(A&amp;amp;&amp;amp; a) : m_ptr(a.m_ptr)&amp;#123;a.m_ptr = &lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;move construct&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~A()&amp;#123;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; m_ptr; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;destruct&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* m_ptr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
  </entry>
  
</feed>
