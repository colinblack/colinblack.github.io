<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Colin&#39;s Home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-16T05:42:16.801Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Colinblack</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tcp-ip面试</title>
    <link href="http://yoursite.com/2020/02/16/tcp-ip%E9%9D%A2%E8%AF%95/"/>
    <id>http://yoursite.com/2020/02/16/tcp-ip%E9%9D%A2%E8%AF%95/</id>
    <published>2020-02-16T05:31:11.000Z</published>
    <updated>2020-02-16T05:42:16.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><p>tcp连接是永久的只要没断开<br>tcp连接是指tcp协议栈维护的状态<br>tcp 流式协议，数据是有序的。面向连接可靠，慢，开销大，容易受攻击<br>udp 数据报协议，数据不保证有序。不需要连接， 不可靠，快，开销小</p><a id="more"></a>  <h2 id="三次握手与四次挥手"><a href="#三次握手与四次挥手" class="headerlink" title="三次握手与四次挥手"></a>三次握手与四次挥手</h2><p>三次握手：<br> &nbsp;&nbsp;&nbsp;1.客户端发起连接请求，SYN=1，seq=y, 客户端进入SYN_SENT状态<br> &nbsp;&nbsp;&nbsp;2.服务端收到连接，SYN=1,ack=y+1, seq=q, 服务端进入SYN_RCVD状态<br> &nbsp;&nbsp;&nbsp;3.客户端收到服务端的回应, ACK=1，ack=q+1, 客户端进入ESTABLISHED，服务端收到后也进入ESTABLISHED   </p><p>四次挥手：<br> &nbsp;&nbsp;&nbsp;&nbsp;主动关闭：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.主动关闭方close FIN=1, 进入FIN_WAIT_1状态<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.被动关闭方收到请求, 发送 ACK=1确认后进入CLOSE_WAIT状态，主动关闭方收到后进入FIN_WAIT_2<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.被动关闭close 发送FIN=1, 进入LAST_ACK状态<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.主动关闭方收到后，发送ACK=1，进入TIME_WAIT状态<br> &nbsp;&nbsp;&nbsp;&nbsp;同时关闭：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;双方发送ACK后进入CLOSING，不会有FIN_WAIT_2,LAST_ACK, CLOSEWAIT    </p><p>序号：<br> &nbsp;&nbsp;&nbsp;每个字节的数据都有自己的序号，对端接收的数据是乱序时用来确定顺序  </p><p>ISN:<br> &nbsp;&nbsp;&nbsp;三次握手第一个连接时的序列号     </p><p>判断syn flood攻击：  </p><pre><code>netstat -nap | grep SYN_RECV        </code></pre><p>防止Syn Flood方法：<br> &nbsp;&nbsp;&nbsp;1.清除所有的半连接<br> &nbsp;&nbsp;&nbsp;2.syn cookie(sysctl.conf tcp_syncookies选项)  </p><p>半关闭状态：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主动关闭端发送FIN，被动关闭端回ACK后  </p><p>三次握手中握手包丢了会怎么样<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在第三次握手中丢包，服务端会有一个定时器，负责重发，会重发5次，第一次1s，以后时间在上次基础上翻倍，如果客户端还是回ack服务端会发rst  </p><h2 id="三次握手，四次挥手的原因"><a href="#三次握手，四次挥手的原因" class="headerlink" title="三次握手，四次挥手的原因"></a>三次握手，四次挥手的原因</h2><p>三次握手:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.服务端的seq(序号)和ack(确认号)是一起发给客户端的<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.客户端如果不发ack包， 服务端一直会超时重传（防止syn flood攻击）<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.三次握手的本质是为了确认连接双方的初始序列号<br>四次挥手：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.ACK 和 FIN 是分开的<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.TCP是全双工协议，一端可读可写，半关闭只关闭了写端，还可以读数据  </p><h2 id="TIME-WAIT状态是什么，为什么会有，那一方会有"><a href="#TIME-WAIT状态是什么，为什么会有，那一方会有" class="headerlink" title="TIME_WAIT状态是什么，为什么会有，那一方会有"></a>TIME_WAIT状态是什么，为什么会有，那一方会有</h2><p>time_wait:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主动关闭的一端发出ACK包后进入的状态，等待2MSL时间后进入CLOSE状态<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主动发送 RST段的一方，不会进入TIME_WAIT 状态<br>原因:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.保证TCP全双工通信可靠性<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有TIME_WAIT，对端没收到ACK包会重发FIN包，在2MSL内会重发ACK包<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有TIME_WAIT，主动关闭方直接进入CLOSE状态，收到FIN包时会返回RST错误(ECONNRESET)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果主动关闭方挂掉，对端会一直重发FIN，知道重置连接<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2. 保证建立新连接时，旧连接重传的包在网络中小时而不影响新连接<br>TIME_WAIT引发的问题:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.进程退出后，端口不能再次绑定(解决:SO_REUSEADDR)<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.出现大量的TIME_WAIT<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一般在高并发短连接，服务器主动关闭socket, 出现大量TIME_WAIT，导致部分用户连不上<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决办法：修改内核相关参数(/etc/sysctl.conf, 重用与快速回收)       </p><h2 id="TCP相关操作"><a href="#TCP相关操作" class="headerlink" title="TCP相关操作"></a>TCP相关操作</h2><p>查看系统支持端口号范围：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cat /proc/sys/net/ipv4/ip_local_port_range<br>扩大可用端口范围:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 15000 65000 &gt; /proc/sys/net/ipv4/ip_local_port_range<br>查看tcp连接默认的timeout时长:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cat /proc/sys/net/ipv4/tcp_fin_timeout<br>缩短timeout的时间:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;echo 30 &gt; /proc/sys/net/ipv4/tcp_fin_timeout<br>统计tcp各个状态数:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;netstat -ant|awk ‘/^tcp/ {++S[$NF]} END {for(a in S) print (a,S[a])}’<br>知名服务器端口定义：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/etc/services  </p><h2 id="TCP头部"><a href="#TCP头部" class="headerlink" title="TCP头部"></a>TCP头部</h2><p>固定20 + 可选项40 = 最大60<br>mss在可选项中<br>mss和MTU：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mss: 最大报文段长度，tcp能发的数据长度，只在三次握手的第一次握手发送给对端（一般1460）<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mtu: 最大传输单元， 网卡一次发送数据的大小（一般是1500）<br>修改mss iptable<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看mtu netstat -i<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;修改mtu vim /etc/network/interfaces /etc/init.d/networking restart<br>PUSH:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;发送方最后发送的TCP段将会被标记为push<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接收方收到push标志到段，将接收缓冲区的内容拷贝到应用进程  </p><p>URG与紧急指针:<br>紧急指针只在URG=1的时候有用<br>紧急指针实际是序列号的偏移量<br>TCP只支持一个字节的紧急数据<br>紧急数据及linux中的带外数据（MSG_OOB）<br>可以在select设置exceptfds，在epoll中EPOLLPRI监听<br>seq:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决乱序<br>ack:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决丢包<br>window:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;流控<br>tcpflag:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tcp状态机<br>tcp头中的窗口是指真个滑动窗口大小吗？  </p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>延时ack：<br> &nbsp;&nbsp;&nbsp;接收数据的一方会根据需要延时发送ack(linux 中动态调节算法在快速ack和延时ack中切换)<br> &nbsp;&nbsp;&nbsp;一般情况下：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.当接收方有数据发送，ack会和数据一起发送<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.如果没有数据会延时200ms，在这期间有数据会和数据一起发送，如果过了时间没有数据，ack会被发送<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3.如果延时期间又有第二个数据到来会立即发送ack<br> &nbsp;&nbsp;&nbsp;优点：减少了发送的分段，提高了网络利用率，节省带宽<br> &nbsp;&nbsp;&nbsp;缺点：增大网络延迟<br> &nbsp;&nbsp;&nbsp;关闭延时发送：TCP_QUICKACK<br> &nbsp;&nbsp;&nbsp;注意：每次recv后要重新设置<br>nagle算法:<br> &nbsp;&nbsp;&nbsp;发送数据的一方会累积数据直到接收方发来ack包后才将数据一起发送出去（最多累积到一个mss的大小），为了尽可能的发送大块数据<br> &nbsp;&nbsp;&nbsp;优点：提高了吞吐量<br> &nbsp;&nbsp;&nbsp;缺点：增大网络延时<br> &nbsp;&nbsp;&nbsp;nagle和延时确认都是为了减少小包   </p><p>滑动窗口:<br> &nbsp;&nbsp;&nbsp;目的为了做流量控制，防止对方发送过快导致缓冲区被塞满, 在tcp头的窗口字段确定其大小<br> &nbsp;&nbsp;&nbsp;持续定时器：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当对端窗口为0是，为防止本端死等，会定时发送长度为1的探测报文段（时间层指数增长）<br> &nbsp;&nbsp;&nbsp;问题：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;糊涂窗口综合征：<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;滑动窗口变小导致发送的数据量表小，久之导致网络传输效率变低<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;解决方法:<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nagle算法<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clark算法和延时ACK  </p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>网络拥塞:<br> &nbsp;&nbsp;&nbsp;路由器等网络设备来不及处理高数率到来的流量出现的丢包现象<br> &nbsp;&nbsp;&nbsp;判断：1.ack超时 2.连续收到同样的ack  </p><p>慢启动：<br> &nbsp;&nbsp;&nbsp;tcp会将大的数据分成若干小的分组，分为若干次发送，而不是一次全部发出去<br> &nbsp;&nbsp;&nbsp;cwdn按照两倍大小增加，大于慢启动门限是进入拥塞避免算法（指数增长）<br> &nbsp;&nbsp;&nbsp;拥塞窗口（cwdn）<br> &nbsp;&nbsp;&nbsp;慢启动门限（ssthresh）  </p><p>拥塞避免算法<br> &nbsp;&nbsp;&nbsp;cwdn 每次大小加1（线性增长）, 出现拥塞时cwdn和ssthresh被重置（一般ssthresh=cwdn/2, cwdn=1）， 然后进入慢启动算法<br> &nbsp;&nbsp;&nbsp;加法增大，乘法减小  </p><p>快重传：<br> &nbsp;&nbsp;&nbsp;接收方收到一个失序的报文段， 会不断重发相同的ACK（没收到包的序号）<br> &nbsp;&nbsp;&nbsp;发送方连续收到三个相同的Ack, 会立即发送对方Ack的包<br> &nbsp;&nbsp;&nbsp;解决了超时的问题， 但是没有解决重传哪些包的问题（需要sack算法）                            </p><p>快恢复：<br> &nbsp;&nbsp;&nbsp;出现超时重传或快重传（连续三个重复的ACK包)时:<br> &nbsp;&nbsp;&nbsp;ssthresh &nbsp;= cwdn/2<br> &nbsp;&nbsp;&nbsp;cwdn = ssthresh  </p><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>快速重传与超时重传<br>超时重传:<br> &nbsp;&nbsp;&nbsp;RTO:(超时重传时间，发送方发出一个包，会启动定时器，定时器超时未收到包，则会重发，这个时间成为重传超时)， 由RTT（数据往返时间）根据公式计算出<br> &nbsp;&nbsp;&nbsp;RTO时间指数方式增加<br> &nbsp;&nbsp;&nbsp;定时器超时后，在滑动窗口内没有收到ACK的包都会重传（sack算法）<br>设置重发次数：<br> &nbsp;&nbsp;&nbsp;/proc/sys/net/ipv4/tcp_retries1<br> &nbsp;&nbsp;&nbsp;/proc/sys/net/ipv4/tcp_retries2  </p><h2 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h2><p>保活定时器<br>服务端探测死连机制（探测客户端宕机或重启, &nbsp;如果是主动关闭连接）<br>缺点：无法识别客户端宕机和还是报文不可达<br>设置：SO_KEEPALIVE  </p><h2 id="数据在不同层的叫法"><a href="#数据在不同层的叫法" class="headerlink" title="数据在不同层的叫法"></a>数据在不同层的叫法</h2><p>数据链路层 帧<br>网络层 包（tcp）, 报（udp）<br>传输层 段  </p><h2 id="arp是什么，实现，怎么找到MAC-arp欺骗"><a href="#arp是什么，实现，怎么找到MAC-arp欺骗" class="headerlink" title="arp是什么，实现，怎么找到MAC, arp欺骗"></a>arp是什么，实现，怎么找到MAC, arp欺骗</h2><p>利用arp缓存中ip与mac的映射，如果有对方mac可以直接通信，没有发给rap广播， 当对方收到后会将自己的MAC填到包里面返回<br>同时将发送方的ip和mac映射放在arp缓存中<br>arp欺骗: 主要方式是中间人攻击，达到获取通信双方数据又不被发现的效果<br>预防：使用arp网关  </p><h2 id="TCP粘包处理"><a href="#TCP粘包处理" class="headerlink" title="TCP粘包处理"></a>TCP粘包处理</h2><p>利用包体长度，bodylen<br> &nbsp;&nbsp;&nbsp;1. 如果缓冲区里面的消息长度小于消息头长度，不处理<br> &nbsp;&nbsp;&nbsp;2. 如果缓冲区长度大于等于bodylen + headlen, 处理  </p><h2 id="HTTP-请求的过程"><a href="#HTTP-请求的过程" class="headerlink" title="HTTP 请求的过程"></a>HTTP 请求的过程</h2><p>建立TCP连接-&gt;发送请求行-&gt;发送请求头-&gt;（到达服务器）发送状态行-&gt;发送响应头-&gt;发送响应数据-&gt;断TCP连接  </p><p>参考：<br><a href="https://blog.csdn.net/dog250/article/details/13760985" target="_blank" rel="noopener">TCP的TIME_WAIT快速回收与重用</a><br><a href="https://www.cnblogs.com/dadonggg/p/8778318.html" target="_blank" rel="noopener">解决TIME_WAIT过多造成的问题</a><br><a href="https://elf8848.iteye.com/blog/1739571" target="_blank" rel="noopener">TCP/IP TIME_WAIT状态原理</a><br><a href="https://blog.csdn.net/wuji0447/article/details/78356875" target="_blank" rel="noopener">tcp状态介绍最详细–没有之一</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&mid=2666543559&idx=1&sn=83cf0e9367511d6b311909a5b3dfc81e&chksm=80dcfd6cb7ab747af19259cce70621b269c5fae25582af7c57f5be904bc18e216625cf6f4157&mpshare=1&scene=24&srcid=0110n9eggIf8eEIoZnl2Loe5&key=02793bf78abe30c4c571e7a6695d4645e0c3637a779c7915ba755677395083d39ee60f9a9d204e28b6d06d279fff9d0a25171eac0cb3e8f126cf46a027d6459f015c13308729af2f9d27c88c38e270c4&ascene=14&uin=ODI0NTI3MTg0&devicetype=Windows+7&version=62060728&lang=zh_CN&pass_ticket=wXb/sgBYyv1S7izs0CuJXuDgNxtBHPyjdhjnyZMw7twBDQnbBA0IyQV1EnfMvwsI" target="_blank" rel="noopener">“三次握手，四次挥手”你真的懂吗？</a><br><a href="https://blog.csdn.net/wdscq1234/article/details/52430382" target="_blank" rel="noopener">TCP-IP详解：Delay ACK</a><br><a href="https://my.oschina.net/xinxingegeya/blog/485643" target="_blank" rel="noopener">TCP Nagle算法&amp;&amp;延迟确认机制</a><br><a href="https://blog.csdn.net/ce123_zhouwei/article/details/9050797" target="_blank" rel="noopener">TCP中的Nagle算法</a><br><a href="https://blog.csdn.net/wdscq1234/article/details/52444277" target="_blank" rel="noopener">TCP-IP详解：滑动窗口（Sliding Window)</a><br><a href="https://www.zhihu.com/question/32255109" target="_blank" rel="noopener">TCP协议的滑动窗口具体是怎样控制流量的</a><br><a href="https://blog.csdn.net/ordeder/article/details/43243425" target="_blank" rel="noopener">TCP带外数据（URG，MSG_OOB</a><br><a href="https://blog.csdn.net/gbasp2008/article/details/47666421" target="_blank" rel="noopener">带外数据和TCP紧急指针</a><br><a href="https://blog.csdn.net/u012122743/article/details/46484675" target="_blank" rel="noopener">TCP紧急数据</a><br><a href="https://blog.csdn.net/wdscq1234/article/details/52476231" target="_blank" rel="noopener">TCP-IP详解：超时重传机制</a><br><a href="https://blog.csdn.net/wdscq1234/article/details/52503315" target="_blank" rel="noopener">TCP-IP详解：SACK选项（Selective Acknowledgment）</a><br><a href="https://blog.csdn.net/q1007729991/article/details/70185266" target="_blank" rel="noopener">27-TCP 协议（快重传与快恢复）</a><br><a href="https://perthcharles.github.io/2015/09/07/wiki-tcp-retries/" target="_blank" rel="noopener">聊一聊重传次数</a><br><a href="http://www.orczhou.com/index.php/2011/10/tcpip-protocol-start-rto/" target="_blank" rel="noopener">TCP/IP重传超时–RTO</a><br><a href="https://blog.csdn.net/q1007729991/article/details/69091877" target="_blank" rel="noopener">0-Linux 网络编程修炼指南——内功心法</a><br><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a><br><a href="https://zhuanlan.zhihu.com/p/25569676" target="_blank" rel="noopener">从TCP三次握手说起–浅析TCP协议中的疑难杂症（1)</a><br><a href="https://zhuanlan.zhihu.com/p/25596865" target="_blank" rel="noopener">从TCP三次握手说起–浅析TCP协议中的疑难杂症（2）</a><br><a href="http://netsecurity.51cto.com/art/201303/386031.htm" target="_blank" rel="noopener">中间人攻击——ARP欺骗的原理、实战及防御</a><br><a href="https://blog.csdn.net/qq_37969433/article/details/79587026" target="_blank" rel="noopener">ARP欺骗的两种方式</a><br><a href="https://blog.csdn.net/Mary19920410/article/details/72857764" target="_blank" rel="noopener">浅析TCP之头部可选项</a><br><a href="https://blog.csdn.net/mary19920410/article/details/58030147" target="_blank" rel="noopener">TCP报文格式详解</a><br><a href="https://www.cnblogs.com/xiaomayizoe/p/5258754.html" target="_blank" rel="noopener">TCP和UDP的优缺点及区别</a><br><a href="https://blog.csdn.net/freeelinux/article/details/53823731" target="_blank" rel="noopener">muduo库chat server对TCP粘包问题的处理</a><br><a href="https://blog.csdn.net/yusiguyuan/article/details/17270679" target="_blank" rel="noopener">TCP分包方法 &amp;&amp; 粘包处理策略</a><br><a href="https://blog.csdn.net/lu_embedded/article/details/77430050" target="_blank" rel="noopener">Linux 网络编程——TCP 粘包及其解决方案</a><br><a href="https://juejin.im/post/5a8102e0f265da4e710f5910" target="_blank" rel="noopener">HTTP面试题都在这里</a><br><a href="https://www.zhihu.com/question/23202402" target="_blank" rel="noopener">HTTP是一个无状态的协议。这句话里的无状态是什么意思</a><br><a href="https://www.zhihu.com/question/24938934" target="_blank" rel="noopener">服务端是如何主动推送信息到客户端的？</a><br><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">HTTP 协议入门</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIwNTc3OTAxOA==&mid=2247484323&idx=1&sn=5513334623b73352034a828badfe985d&chksm=972afa86a05d7390fe96222718fd9ce6c21fe700af7e7f9396449815a5323e7315d96681bcac&scene=0&xtrack=1&key=a539a6045067ac190e5c71cc4876a35ec2cab39ecc57c3618a3c22861a71c8bfa13cb8c4e1190e7ca56b6fa54c00b894874dabfdb24eb7aa3f45382bd07dd271a25982549dfd70f959b71db7aeb5d371&ascene=14&uin=ODI0NTI3MTg0&devicetype=Windows+7&version=62060739&lang=zh_CN&pass_ticket=UG6jIZiPy0h82EWKj8fu5ZN0dIyjwygUpMCiLLSskgXdEE9mhfeXBtYPbOR2lLEE" target="_blank" rel="noopener">程序员过关斩将–面试官再问你Http请求过程，怼回去！</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;TCP和UDP的区别&quot;&gt;&lt;a href=&quot;#TCP和UDP的区别&quot; class=&quot;headerlink&quot; title=&quot;TCP和UDP的区别&quot;&gt;&lt;/a&gt;TCP和UDP的区别&lt;/h2&gt;&lt;p&gt;tcp连接是永久的只要没断开&lt;br&gt;tcp连接是指tcp协议栈维护的状态&lt;br&gt;tcp 流式协议，数据是有序的。面向连接可靠，慢，开销大，容易受攻击&lt;br&gt;udp 数据报协议，数据不保证有序。不需要连接， 不可靠，快，开销小&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="tcp" scheme="http://yoursite.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>cpp细节</title>
    <link href="http://yoursite.com/2020/01/08/cpp/cpp%E7%BB%86%E8%8A%82/"/>
    <id>http://yoursite.com/2020/01/08/cpp/cpp%E7%BB%86%E8%8A%82/</id>
    <published>2020-01-08T11:59:12.000Z</published>
    <updated>2020-02-16T05:22:10.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动构造函数中如果有拷贝动态内存要注意将指针赋空"><a href="#移动构造函数中如果有拷贝动态内存要注意将指针赋空" class="headerlink" title="移动构造函数中如果有拷贝动态内存要注意将指针赋空"></a>移动构造函数中如果有拷贝动态内存要注意将指针赋空</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() : m_ptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>))&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) : m_ptr(a.m_ptr)&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    A(A&amp;&amp; a) : m_ptr(a.m_ptr)&#123;a.m_ptr = <span class="literal">nullptr</span>; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"move construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">    ~A()&#123;<span class="keyword">delete</span> m_ptr; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destruct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span>* m_ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="重载决议"><a href="#重载决议" class="headerlink" title="重载决议"></a>重载决议</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> a_;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">foo(T&amp;&amp; v) : a_&#123;<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(v)&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="keyword">const</span> foo&amp; rhs) : a_&#123;rhs.a_&#125;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">operator</span> <span class="built_in">std</span>::<span class="keyword">uint8_t</span>()&#123;<span class="keyword">return</span> a_;&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    foo bar1&#123;<span class="number">256</span>&#125;, bar2&#123;bar1&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(bar1.a_ == bar2.a_)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，编译器会选择会选择移动构造函数而不是拷贝构造，应为如果调用拷贝构造bar1会存在隐式转换.但是如果是默认的拷贝构造则会优先被调用<br><a href="https://stackoverflow.com/questions/53902448/template-constructor-and-copy-constructor" target="_blank" rel="noopener">Template constructor and copy constructor</a></p><h2 id="vector删除性能对比"><a href="#vector删除性能对比" class="headerlink" title="vector删除性能对比"></a>vector删除性能对比</h2><p><a href="https://sourcegraph.com/github.com/colinblack/language/-/blob/c++/stl/vector/vector_pop_back.cc#L14" target="_blank" rel="noopener">vector_pop_back.cc</a></p><h2 id="vector-构造函数"><a href="#vector-构造函数" class="headerlink" title="vector 构造函数"></a>vector 构造函数</h2><p>vector<inv> v(10)　构造一个size(不是capacity)为10的vector</p><h2 id="关联容器的构造函数"><a href="#关联容器的构造函数" class="headerlink" title="关联容器的构造函数"></a>关联容器的构造函数</h2><p>如map set unordered_map 中 使用[]操作符，首先会调无参构造函数，插入元素正确的方式是使用insert, 但是这会调用两次拷贝构造，需使用std::move。使用[]操作符复制是调用的是拷贝操作符，使用insert会调拷贝构造</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Item(<span class="keyword">int</span> a): i(a)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a_;</span><br><span class="line">    <span class="keyword">int</span> b_;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Item&gt; v_;</span><br><span class="line">    Demo()</span><br><span class="line">    &#123;</span><br><span class="line">        a_ = <span class="number">0</span>;    </span><br><span class="line">        b_ = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"no param "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Demo(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="built_in">vector</span>&lt;Item&gt;&amp; v)</span><br><span class="line">    &#123;</span><br><span class="line">        a_ = a;    </span><br><span class="line">        b_ = b;</span><br><span class="line">        v_ = v;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"param "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Demo(<span class="keyword">const</span> Demo&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        a_ = obj.a_;    </span><br><span class="line">        b_ = obj.b_;</span><br><span class="line">        v_ = <span class="built_in">std</span>::move(obj.v_);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy construct "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Demo&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Demo&amp; obj)</span><br><span class="line">    &#123;</span><br><span class="line">        a_ = obj.a_;</span><br><span class="line">        b_ = obj.b_;</span><br><span class="line">        v_ = <span class="built_in">std</span>::move(obj.v_);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"copy operator "</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;Item&gt; v;</span><br><span class="line">    v.push_back(Item(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">unsigned</span>, Demo&gt; m;</span><br><span class="line">    m.insert(&#123;<span class="number">1</span>, Demo(<span class="number">1</span>, <span class="number">2</span>, v)&#125;);</span><br><span class="line">    m[<span class="number">1</span>] = Demo(<span class="number">1</span>, <span class="number">2</span>, v);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; m[<span class="number">1</span>].a_ &lt;&lt; <span class="string">" "</span> &lt;&lt; m[<span class="number">1</span>].b_ &lt;&lt; <span class="string">" "</span> &lt;&lt; m[<span class="number">1</span>].v_.size() &lt;&lt; <span class="string">" "</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C中的结构体"><a href="#C中的结构体" class="headerlink" title="C中的结构体"></a>C中的结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd_set rd;</span><br><span class="line">fd_set all;</span><br><span class="line">ll = rd; <span class="comment">//合法</span></span><br><span class="line">fd_set 是个结构体, 里面有一个整型数组， c++中则会调用拷贝操作符</span><br></pre></td></tr></table></figure><h2 id="STL-中的类型"><a href="#STL-中的类型" class="headerlink" title="STL 中的类型"></a>STL 中的类型</h2><p>SIZE_TYPE：不同平台下长度不一样， 64位下是8字节，unsigned log<br><img src="/images/f1a84799-5f3b-41a6-a52d-d75a92fdea4d.png" alt="size_type"></p><p>这里返回值不能用unsigned去接， 否则找不到会返回-1, 实际find找不到只会返回sting::npos, 显然是类型溢出</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;移动构造函数中如果有拷贝动态内存要注意将指针赋空&quot;&gt;&lt;a href=&quot;#移动构造函数中如果有拷贝动态内存要注意将指针赋空&quot; class=&quot;headerlink&quot; title=&quot;移动构造函数中如果有拷贝动态内存要注意将指针赋空&quot;&gt;&lt;/a&gt;移动构造函数中如果有拷贝动态内存要注意将指针赋空&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A() : m_ptr(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;))&amp;#123;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;construct&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A(&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; A&amp;amp; a) : m_ptr(a.m_ptr)&amp;#123;&lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;copy construct&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    A(A&amp;amp;&amp;amp; a) : m_ptr(a.m_ptr)&amp;#123;a.m_ptr = &lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;move construct&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ~A()&amp;#123;&lt;span class=&quot;keyword&quot;&gt;delete&lt;/span&gt; m_ptr; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;string&quot;&gt;&quot;destruct&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;built_in&quot;&gt;std&lt;/span&gt;::&lt;span class=&quot;built_in&quot;&gt;endl&lt;/span&gt;;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;* m_ptr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/categories/c/"/>
    
    
  </entry>
  
</feed>
