---
title: mysql面试
date: 2020-03-03 20:17:16
categories: 
    - 中间件  
tags: 
    - 面试  
    - mysql  
---
<!-- more -->
## 基础
###  MySQL 执行一条查询语句的内部执行过程   
 * 答案：  
 链接器=》分析器=》优化器=》执行器=》存储引擎    
1. 客户端先通过连接器连接到 MySQL 服务器   
2. 连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器     
3. 分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器  
4. 优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好  
5. 优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回   

* 详解：  
查询、更新等语句都会走下面这个图(mysql逻辑架构图)     
![p1](https://i.loli.net/2020/11/15/Pl9BhwNpSVEWzAk.png)     
大体上MySQL=Server层+存储引擎层  
Server层实现的功能：内置函数(日期、时间、数学、加密函数)和跨存储引擎功能(存储过程、触发器、视图)  
存储引擎层功能：数据存储和提取，架构模式为插件式，最常用的存储引擎InnoDB(5.5.5后默认引擎)、MyISAM、Memory    
连接器： 
负责与客户端建立连接，获取权限，维持和管理连接     
建立连接    
mysql  -h$ip  -P$port  -u$user -p    
获取权限   
如果用户密码不对， 则报错"Access denied for user"， 然后退出  
如果用户密码认证通过，连接器会到权限表里查出你拥有的权限 (即使管理员修改了你的权限也只能下次重新连接是生效)    
管理连接  
查询连接状态   
show processlist
其中Command 为Sleep的表示空闲连接， 如果空闲时间超过wait_timeout则自动断开     
查询缓存：   
以key-value的形式存在内存中，key是查询命令，value是结果  
缓存利大于弊，查询缓存失效非常频繁，只要对一个表更新，这个表上所有查询缓存都会被清空 , 更新频繁的数据库不适应缓存   
使用场景：  业务是一张静态表，长时间不更新，例如配置信息  
设置sql语句默认不查询   
 set session query_cache_type=DEMAND  #当前会话  
 Mysql8.0后没有查询缓存功能   
分析器      
优化器：    
表里有多个索引是，决定用哪个索引，或一个语句有多表关联(join)时，决定各个表连接顺序   
执行器：    
先判断有没有查询权限，没有则返回错误 ， 如果有则使用引擎提供的接口      


二、 MySQL执行一条更新语句内部的执行过程    
* 答案:
与查询语句的流程一样：链接器=》分析器=》优化器=》执行器=》存储引擎   
执行器和存储引擎(innodb)的细节不同：   
1. 执行器先找引擎取指定主键的数据（B-,b+树）, 如果数据在内存上直接返回给执行器，否则从磁盘读入内存在返回   
2. 执行器根据更新语句对数据进行操作后调用引擎接口写入  
3. 引擎将这行数据更新到内存，并将更新操作记录到redo log, 此时redo log处于prepare状态，通知执行器可以提交事务。  
4. 执行器生成这个操作的binlog, 并将binlog写入磁盘
5. 执行器调用引擎提交事务接口，引擎讲redo log改为commit状态，更新完成      


## 索引  
### 主键索引和非主键索引有什么区别（innodb引擎下）
1. 主键索引叶子节点中存储整行数据, 非主键索引存的是主键
2. 非主键索引可能存在回表查询， 因此IO操作可能多于主键索引, 索引应该避免回表查询   
3. 创建方式上，如果表中有主键，会自动生成主键索引。表中无主键，将唯一索引+not null 作为主键
   如果没有， mysql自动创建rowid, 隐式列。 非主键索引要主动创建
4. 非主键索引会占用额外的磁盘空间，会降低更新效率   

### 为什么建议使用主键自增索引  
表的存储结构， 表空间有段(索引=索引段+数据段)组成， 区=1M=64页， 1页=16k
不使用自增索引插入数据时B+树的结构可能也会跟着调整， 可能产生磁盘碎片降低磁盘利用率

### 为什么索引使用整型而不是字符串  

















