---
title: 模板
date: 2020-03-29 10:24:59
categories:
    - c++
tags:
    - 泛型
---


<!-- more -->
## 函数模板
定义模板是不会生成代码，只有当实例化时才会生成  
### 类型模板参数
```cpp
    template<class T>
    T add(T a, T b){
        return a + b;
    }

```

### 非类型模板参数
非类型是指不是泛型， 即基本类型
即显示使用<>指定
非类型模板参数必须是常量， 因为模板代码在编译期生成
* 所有参数都是非类型
```cpp
template<int a, int b>
int add(){
    return a + b;    
}

add<1, 2>() //显示指定参数

```
* 非类型和类型参数混合
```cpp
template<class T, int a , int b>
int add(T c){
    return (int)c + a + b;    
}

add<int, 1, 2>(3);
```
* 非类型模板也可以不用<>指定
```cpp
template<unsigned L1, unsigned L1>
int strcomp(const char(&p1)[L1], const char(&p2)[L2]){  //数组的引用
    return strcmp(p1, p2);
}

strcomp("test", "test2"); //字符串长度由编译器默认推到
strcomp<5, 6>("test", "test2"); //也可以显示指定
```

## 类模板
类模板编译器不能自动推导参数所以要显示用<>指定  

### 类模板成员函数
* 定义在类内部不用写类型参数   
```cpp
template<class T>
class A{

public:
    void func(){}
};

```

* 定义在类外部   

```cpp
template<class T>
void A<T>::func(){

}

```


### 非类型模板参数
非类型参数不能是浮点数和类
```cpp
template <class T, int V = 100>
class A{
public:
void func();

};
template<class T, int V>
void A<T, V>::func(){

}
```

## typename使用场景  
* 模板类型参数   
* 使用类的类型成员， 用typename来标示这个类型      
一般使用::后面跟类型时，编译器默认会当作类的成员变量。为防止这种情况使用必须使用typename(这里不能使用class代替)    

例1：

```cpp
template <class T>
class mystring{
public:
    typedef T* Iterator;

    Iterator begin();
};

template<class T>
typename mystring<T>::Iterator mystring<T>::begin(){
    //....    
}

```

例2：
```cpp
//饿汉单例模式
template <class T>
class CHSingleton
{
protected:
    CHSingleton()
    {
        _destory.init();
    }

    ~CHSingleton()
    {
    }

public:
    static T *Instance() { return _instance; }
    class CDestory
    {
    public:
        CDestory()
        {
            std::cout << "CDestory" << std::endl;
        }
        ~CDestory()
        {
            std::cout << "~CDestory" << std::endl;
            delete CHSingleton::_instance;
            CHSingleton::_instance = nullptr;
        }
        static void init() {}
    };

private:
    thread_local static T *_instance;
    static CDestory _destory;
};

template <class T>
thread_local T *CHSingleton<T>::_instance = new T;

template <class T>
typename CHSingleton<T>::CDestory CHSingleton<T>::_destory;

```

## 可调用对象做函数模板的默认参数  
c++11以后支持模板函数默认参数  
```cpp
typedef void (*func)(int, int);

void func1(int a, int b){

}
//函数指针
template <class T, class Func=func1>
void tfunc(const T& i, const T& j, Func f= func1){
    f(i, j);
}


//函数对象
class Obj{
public:
    void operator()(int, int){
    }
}

template <class T, class O=Obj>
void tfunc(const T& i, const T& j, O o= Obj()){
    o(i, j);
}
```


## 成员函数模板   
成员函数模板不能是虚函数， 
### 普通类的成员函数模板 
```cpp
class A{
public:
    template <class T>
    void func(T t){
    }
};

A a;
a.func(1);
```

### 类模板中的成员函数模板   
* 类成员模板函数定义在类内   
```cpp
template <class C>
class A{
public:
    template<class T1, class T2>
    A(T1 a, T2 b){

    }

    template<class T3>
    void func(T3 c){
    }

private:
    C c;
};

A<int> a;
a.func(1, 2);
```
* 类成员模板函数定义在类外  
```cpp
temp<class C>  //先写类模板申明
temp<class T1, class T2> //再写成员函数模板申明 
A<C>::A(T1 a, T2 b){

}
```
## 模板显式实例化
为防止多个cpp文件中实例化相同的模板类， c++11中使用显示实例化解决
每种类型的模板只需实例化一次， 其他的cpp文件声明就行， 只有使用到该类型模板才用实例化  
```cpp
//a.cpp
template  A<float>;  //显式实例化类
template  void func(int a, int b) ;//显示实例化函数

//b.cpp
extern template A<float>; //显式实例化类声明
extern template  void func(int a, int b) ;//显示实例化函数申明

```
类模板的实例化会实例化类模板的所有成员函数， 包括内联和类成员模板函数(vs中)    

## using 定义模板别名 
* 定义一个值为任意参数的模板别名  
```cpp
template<class T>
using s_map = std::map<string, T>;

s_map<int> m;
m.insert({"first", 1});

```
* 定义一个函数指针模板
```cpp
template<class T>
using funcptr = bool (*)(T, T);

bool func(int i, int j){

}
funcptr<int> f_ptr;
f_ptr = func;
```

## 显示指定模板参数  
```cpp
template <class T1, class T2, class T3>
T1 sum(T2 i, T3 j){
    T1 res = i + j;
    return res;
}
//参数2,3能推导出来， 能省略
auto res = sum<double>(200000000, 200000000);

template <class T1, class T2, class T3>
T3 sum(T1 i, T2 j){
    T3 res = i + j;
    return res;
}
//参数不能省
auto res = sum<double, double, double>(200000000, 200000000);

```