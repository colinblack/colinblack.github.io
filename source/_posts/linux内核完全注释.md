---
title: 《Linux内核完全注释》笔记
date: 2020-02-18 19:46:41
categories:
    - Linux
---

<!-- more -->  
## 第二章 Linux内核体系结构  
### Linux内核模式  
操作系统体系结构模式主要分为：  
整体式单内核(宏内核)  
层次式微内核  

单核模式内核层次:  
调用服务的主程序层  
执行系统调用的服务层  
支持系统调用的底层函数  
![p1](/images/66dc1980-6148-4883-aa5b-695b3a9e0817.png)  

### Linux内核系统体系结构  
Linux内核主要由5个模块构成：进程调度模块，内存管理模块，文件系统模块，进程间通信模块，网络接口模块  
模块间的依赖关系:  
![p2](/images/fc77df7e-b967-4408-934b-ba46535033e2.png)  

Linux 0.11架构图:  
![p3](/images/00367ae6-72cc-4b02-9f9e-4ecefac7afce.png)  


### Linux进程控制  
内核态程序是不可抢占的(不会被schedule切换)， 用户态程序可以被抢占  
一个进程可以在内核态或用户态下执行，内核堆栈和用户堆栈是分开的  

#### 任务数据结构  
进程上下文：当一个进程在执行时， CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称为该进程的上下文。  
睡眠等待状态被分为可中断和不可中断  

#### 进程五种运行状态  
运行状态：进程正在被CPU执行，或者准备就绪随时可由调度程序执行  
可中断睡眠状态：当系统产生中断或释放进程正在等待的资源或进程收到一个型号，进程能被唤醒转换到就绪状态  
不可中断睡眠状态：只有被使用wake_up()明确唤醒时才能转换到可运行的就绪状态  
暂停状态：当进程收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU进入暂停状态，像其发送SIGCONT转换到可运行状态  
僵死状态：进程已停止运行，但父进程还没有询问其状态  
进程状态及转换关系：  
![p4](/images/70009bcf-eeea-4c5d-a784-fa561271b33e.png)  
进程调度发生的情况:  
进程时间片用完  
进程自动放弃CPU使用权    

内核态时进程不能被 抢占，内核执行临界区代码时禁止一切中断  

#### 进程初始化  
sched_init()：  
设置任务0运行环境变量  
预先设置好任务0数据结构个字段  
在全局描述符表中添加任务0的TTS(任务状态段)描述符和LDT(局部描述符表)的段描述符，并把他们分别加载到tr(任务寄存器)和(ldr)局部描述符表寄存器  

move_to_user_mod()：                            
把运行特权级从内核态0级变换到用户态3级, 但是任然继续执行原来的代码.  

#### 创建新进程  
过程：  
使用fork创建，所有金产能都是通过复制进程0得到， 都是进程0的子进程  
申请内存  
复制当前进程数据结构  
清除信号位图  
设置时间片  
设置tss中各寄存器的值  

#### 进程调度  
被抢占的进程仍处于TASK_RUNNING, 但是没被cpu执行，抢占发生在用户态，内核态不能被抢占，Linux 0.11 采用优先级排队调度策略  
schedule 首先在TASK_RUNNING进程中选，谁counter值最大执行谁 如   果这些进程时间片都用完就根据优先权值priority重新分配时间片公式：  
![p5](/images/a0bcedee-f079-4dd0-9643-99de53b48236.png)  
 如果此时没有其他进程运行，系统就会选择0号进程  

#### 进程切换  
switch_to():  
如果切换的就是当前进程则什么也不做， 否则ljmp新进程的tss地址处， cpu各寄存器状态会保存到原来进程的tss， 然后将新进程的tss寄存器信息恢复到cpu中  

任务切换操作示意图:  
![p6](/images/e0273d2a-56b1-4bea-acc9-bacf3d03238a.png)  


#### 进程终止  
流程:  
用户程序调用exit, 内核执行do_exit  
关闭进程会释放内存，关闭进程打开着的所有文件  
如果有子进程，让init进出给你作为紫金城的父进程  
如果进程是会话头进程且控制终端，则释放子进程，并向会话所有进程发送SIGHUP  
将进程状态至为TASK_ZOMBIE, 并向原父进程发送SIGCHLD  
调用do_exit  

进程终止时，其数据结构还保留，因为父进程要用到  
父进程使用wait或waitpid等待子进程终止  

### Linux内核对内存的使用方法
Linux 0.11内核物理内存分布：
![p6](/images/p1_20200224112830.png)  

Intel CPU两种内存管理系统：内存分段，分页
三种地址
进程的逻辑地址: 程序产生与段相关的偏移地址
CPU的线性地址: 逻辑地址 + 基地址
实际物理内存地址: CPU外部地址总线上的寻址物理内存的地址信号
如果启用了分页机制，线性地址会使用页目录和页表中的项变换成物理地址，如果没有启用线性地址直接成为物理地址

分页机制应用：建立一个大而连续的内存空间映像

虚拟内存，是一种利用二级或外部存储空间，使程序不受物理内存限制的方法，通常要大于物理内存

虚拟内存实现：
程序申请一段内存，如果内存页表中相应页面不存在内存中，CPU产生一个缺页中断，并把引起中断的线性地址放到CR2控制寄存器中， 中断处理程序通过地址把页面从二级存储空间（如硬盘）加载到物理内存， 如果内存已占满，则借助二级存储空间一部分作为交换缓冲区（Swapper）把内存中暂时不用的页面交换到二级缓冲区中，然后吧要求的页面调入内存。

内存映射
虚拟内存通过局部段描述符表(LDT)变换为CPU整个线性地址空间中的地址，再使用也目录表PDT(一级页表)和页表PT(二级页表)映射到物理地址页.

### Linux系统中堆栈的使用方法




